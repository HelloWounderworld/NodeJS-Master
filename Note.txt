Seção 1  - Conhecendo a tecnologia e se preparando para o desenvolvimento:
    Aula 1 - Introdução ao NodeJS:
        Temos 4 recursos que serão essenciais e úteis para melhor produtividade como programador profissional:
        -express : Um framework NodeJS para aplicações WEB
        -EJS - Uma linguagem de modelagem para criação de paginas HTML utilizando JavaScript
        -Nodemon - Um utiliário que reinicia automaticamente o servidor NodeJS quando houver qualquer alteração em nossos scripts
        -npm - Um gerenciador de pacotes JavaScript
        - Nas classes, em todos os momentos será usado o bootstrap.

    Aula 2 - [Extra] Canais de comunicação:
        O Curso Completo do Desenvolvedor NodeJS e MongoDB possui um grupo no Facebook, a proposta é criar uma espaço colaborativo, possibilitando a troca de conhecimentos e experiências entre os participantes do curso, uma ótima oportunidade para conhecer pessoas com os mesmos objetivos profissionais que você!

        Vale lembrar porém que o grupo não é dedicado ao suporte de dúvidas do curso, as dúvidas deverão ser postadas aqui no fórum da Udemy normalmente.

        Link do grupo: https://www.facebook.com/groups/458536931149217/

        Aguardamos você lá.
    
    Aula 3 - Entendendo o conceito client-server e a dinâmica de aplicações web: 
        Aqui vc precisa entender sobre o conceito de cliente servidor. Seguir o link de leitura:
        https://developer.mozilla.org/pt-BR/docs/Learn/Server-side/First_steps/Client-Server_overview
    
    Aula 4 - Download e instalação do NodeJS:
        Download e Instalação do node. Basta visitar a página nodejs.org.

    Aula 5 - [Linux] - Instalação do NodeJS:
        [Linux] - Instalação do NodeJS
        Artigo dedicado a usuários do sistema operacional Linux



        Introdução

        Nesse artigo você aprenderá a como instalar o Node.js e o NPM no Sistema Operacional Ubuntu 16.04.



        Como Instalar Utilizando o NVM

        Nesse artigo iremos usar uma ferramenta chamada nvm, que significa "Node.js version manager" ou "Gerenciador de Versão do Node.js" para realizar a instalação do NodeJS e do NPM.

        Usando o nvm você poderá controlar o seu ambiente de desenvolvimento mais facilmente, com ele teremos acesso a uma série de versões da plataforma NodeJS de tal modo a possibilitar a instalação da que for mais apropriada para as nossas necessidades.

        Para começar, precisaremos obter os pacotes de software do nosso repositório Ubuntu que nos permitirão compilar pacotes de fontes. O script nvm aproveitará estas ferramentas para construir os componentes necessários. Para começar vamos abrir o Terminal do Linux, em seguida vamos rodar os seguintes comandos no Terminal:

        sudo apt-get update

        sudo apt-get install build-essential libssl-dev

        Segue abaixo as imagens da execução dos comandos acima concluídos.
        





        
        Uma vez que os pacotes requeridos estejam instalados, você poderá baixar o script de instalação do nvm com o curl.

        É importante que antes da execução você mude o diretório no terminal para a Área de Tabalho (desktop), pois do contrário o script de instalação não será baixado, e para mudar o diretório do Terminal você pode usar o comando cd (change directory) e na sequência usar o comando abaixo para baixar o script de instalação:

        curl –sL https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh -o install_nvm.sh

        Na sequência, quando o terminal for liberado para digitação novamente, utilize o comando ls (list) para verificar se foi criado um arquivo install_nvm.sh na pasta em que você está.

        Agora que o script de instalação foi criado, devemos executá-lo, e podemos fazer isso através do comando bash, ficando da seguinte maneira:

        bash install_nvm.sh

        Basta esperar a execução do comando finalizar e já temos o NVM instalado em nossa máquina.

        Abaixo temos uma imagem com o processo descrito acima:


        

        Agora para podermos acessar as funções do NVM temos que reiniciar o Terminal, é só fechá-lo e abri-lo novamente. Feito isso podemos instalar o NodeJS.

        Se você usar o comando:

        nvm ls-remote

        Será listado no terminal todas as versões disponíveis do NodeJS, como mostra a imagem abaixo:


        

        No momento da escrita desse artigo a última versão disponível era a v8.1.2.

        Decidimos instalar a versão 6.11.0 do NodeJS por ser a versão mais estável no momento, para realizar a instalação basta você usar o comando:

        nvm install 6.11.0

        Assim que a execução do comando terminar você já terá o NodeJS na versão 6.11.0 e o NPM 3.10.10 instalados na sua máquina. Para listar as versões do NodeJS instaladas através do NVM basta usar o comando:

        nvm ls

        Esse comando deverá listar apenas a versão 6.11.0 e mostra-la como a versão padrão.

        A imagem abaixo mostra o processo de instalação do NodeJS através do NVM e a listagem das versões instaladas:




        E pronto! Você já tem o NVM o NodeJS e o NPM instalados em sua máquina. Para garantir que o NodeJs e o NPM estejam funcionando você pode fazer o teste com os seguintes comandos:

        node –v

        npm –v

        Os comandos acima deverão ter como resultado algo como a imagem abaixo:



        

        Qualquer dúvida ou sugestão é informar ;)

        Bons estudos!!!

    Aula 6 - Instalando o sublime text para criação/edição de scripts:
        Instalar o VSCode ou algum outr sublime text que esteja em alta do momento.

Seção 2 - Projeto prático - primeiros passos para um portal de notícias com NodeJS:
    Aula 1 - Executando arquivos JavaScript no NodeJS:
        Para executar o arquivo JavaScript no NodeJS, bastaria, pelo terminal, entrar na pasta projeto seu e nela digitar "node (nome do arquivo JS)".
    
    Aula 2 - Respondendo requisições HTTP com NodeJS:
        Respondendo requisições HTTP com NodeJS. Basta seguir o arquivo noticias.js.

    Aula 3 - Respondendo requisições com base na url requisitada:
        Respondendo requisições com base na url requisitada. Basta seguir o arquivo noticias.
        
Seção 3 - Ganhando produtividade com o NPM, Express, EJS e Nodemon:
    Aula 1 - Visão geral do NPM, Express, EJS e Nodemon:      
        Ao baixar o node, o npm já vem incluso, para verificar isso bastaria digitar npm -v para verificar a sua versão instalada.
        Para iniciarmos o npm, precisamos ir no terminal e colocar o comando npm init. Ao realizarmos isso e preenchendo as resquições que lhe são solicitadas, no final, será criado um arquivo chamado package.json.
    
    Aula 2 - Iniciando o NPM em nosso projeto:
        Agora, vamos instalar o Express usando o npm. No caso, podemos jogar no terminal npm install express -save.
        A verdade é que podemos digitar somente o npm install express, mas o motivos de colocarmos o '-save' está no fato de que podemos trazer os arquivos instalados dentro da nossa máquina, vide o node_modules eo package-lock.json que apareceu quando colocamos o tal comando no terminal.
        As boas práticas sugerem que tais comandos para que fizemos acima para criarmos o package.json e o node_module sejam feitas dentro do diretório projeto seu.

    Aula 3 - NPM - Instalando o Express:
        No caso, com o express já instalado precisamos fazer uma refatoração do projeto. No caso, no arquivo app.js precisamos fazer require do express.

    Aula 4 - Refactoring do projeto prático portal de notícias com Express:
        Agora, instalamos o EJS usando o npm. No caso, esse recurso vainos permitir escrever páginas html juntamente com instruções do JavaScript.
        Basta colocar o comando pelo terminal acessado o seu diretório projeto npm install ejs --save.
        Depois disso podemos ver que o ejs está disponível dentro de node_modules
        Agora, precisamos ir no arquivo app.js e informar para o express que foi implementado um novo recurso ejs e que será trabalhado em conjunto com o express.
        Para melhor organização vamos criar um diretório novo chamado views e dentro dele colocar arquivos htmls e chamar-las no app.js.

    Aula 5 - NPM - Instalando o EJS - Download das views do projeto prático portal de notícias - Refactoring do projeto prático portal de notícias com EJS:
        Depois que instalamos o recurso ejs vamos refatorar o nosso código. Vamos substituir pelo diretório view que foi baixado que já tem os ejs prontos. E realizar as devidas modificações no app.js que considere tais refatorações.
        Utilize o link disponibilizado como recurso dessa aula para fazer o download das views do projeto prático portal de notícias.

        Bons estudos ;)

        Recursos

    Aula 6 - NPM - Instalando e testando o Nodemon:
        Agora, vamos instalar e testar o Nodemon usando o npm. No caso, ele servirá para que a cada alteração que realizamos no nosso projeto que ele seja renderizado sem a necessidade manula de ter quer parar a renderização para depois renderizar novamente o nosso projeto pelo terminal.
        Para a instalação basta rodar o comando pelo diretório projeto npm install -g nodemon
        Assim, em seguida, rode o comando nodemon (nome do arquivo sem a extensão), nodemon app.
        Dessa forma, qualquer alteração que ocorrer no seu script, o nodemon captará automaticamente e será feito o restart automático.

Seção 4 - Modulando nosso projeto com CommonJS:
    Aula 1 - O que são módulos e o que é CommonJS?:
        Módulos - Permitem organizar melhor os nossos códigos de tal modo que isole uma determinada lógica nossa e que a mesma seja usada de forma recorrente para outras finalidades. Um exemplo de módulos seria as classes que aparecem nas programações orientadas à objetos.
        CommonJS - é que permite definir o formato da construção desses módulos. Uma estrutura de escrita que seja implementado no node de forma natural.
        Para experimentarmos tais recursos usamos vamos criar o arquivo mod_teste.js e dentro dela colocar um exemplo simples
        Feito isso precisa-se ser recuperado na aplicação app.js.
        No caso, o módulo pode retornar qualquer coisa (objeto, string, booleano, classe, etc...)
        Um caso mais comum que se retorna do módulo é uma função.

    Aula 2 - Criando um módulo para configurações do servidor:
        Agora, para não ficar exaustivo, tais módulos podemos encontrar dentro do node_module se verificarmos nas biblioteca (lib). Uma delas no diretório ejs/lib

    Aula 3 - Reestruturando a aplicação e criando um módulo para definição das rotas:
        Vamos agora aprender a modularizar as nossas aplicações. No caso, as requires que temos nos arquivos app.js podemos organizar melhor colocando-as dentro do diretório config que vamos criar e, dentro dela, no arquivo server.js. É necessário colocar o module.exports e especificar quem vc está retornando.
        Deixarei comentado os requires do app.js e nela apenas irei fazer um require que é vinda do diretório config e arquivo server.js
        Vamos modularizar um pouco mais as nossas aplicações, para a melhor organização. Para isso, vamos criar um diretório app e dentro dela mover o diretório view. Além disso, dentro do diretório app, vamos criar o outro diretório routes e movemos o diretório view dentro do diretório app.
        Daí, dentro do diretório routes vamos criar três arquivos .js que representam as respectivas rotas de cada página.
        Após feito isso, vamos precisar apontar os respectivos caminhos que foram feito. E tal caminho vamos configurar no server.js.
        Note que, na configuração dentro do server.js, temos que configurar como se estivessemos no app.js, então os níveis das paths precisam ser levadas em consideração ao app.js e não o arquivo server.js, app.set('views', './app/views');
        Para os arquivos .js que foram criado dentro do routes, precisamos exportar o módulo para que seja possível importar o mesmo no app.js, como podemos ver pelas variáveis que referencia as rotas que criadas, var rotaNoticias = require('./app/routes/noticias');
        Bastaria rodar nodemon app para verificar na porta indicada do localhost para verificar que as rotas funcionam perfeitamente.

Seção 5 - Conectando ao banco de dados MySQL:
    Aula 1 - NPM - Instalando o modulo de conexão do MySQL:
        Vamos agora trabalhar com um banco de dados. No caso, existem vários bancos de dados. Para essa aula, vamos usar o MySQL. No caso, vamos precisar instalar o MySQL jogando no terminal npm install mysql --save.
        Feito a instalação acima, podemos ver que no node_modules vai aparecer um diretório mysql que indica que temos recursos para conseguirmos estabelecer a conexão com o banco de dados MySQL.

    Aula 2 - Extra - Instalando o banco de dados MySQL:
        Agora, vamos verificar se temos ou não o banco de dados MySQL instalado no computador, pois mesmo realizando a instalação dos recursos que permitem a conexão com o banco de dados no processo anterior, nada de adiante se não tivermos um banco de dados do tipo para o uso. https://www.mysql.com/ -> MySQL Community (GPL) Downloads 
        Será necessário criar um cadastro de usuário no site do mysql.
        As instruções de instalação acima, servem para Windows, então para o Mac será um outro pacote. https://dev.mysql.com/doc/mysql-installation-excerpt/8.0/en/osx-installation-pkg.html ou https://dev.mysql.com/downloads/mysql/
        Importante: Durante a instalação, na etapa de configuração, marque a opção "Use Legacy Password Encryption".

    Aula 3 - Extra - Instalando o banco de dados MySQL no OSX (Mac) - Criando e populando o banco de dados do projeto prático portal de notícias:
        Agora, instalado o MySql no seu computador, vamos rodar ela. Para o Windows existem uma série de quesitos que precisam ser satisfeitas para a sua execução. No caso, precisaria entrar até a pasta bin onde está localizado o mysql.exec, tudo pelo terminal, e, finalmente, rodar o comando mysql -u root -p.
        No Linux ou Mac, bastaria, após o mysql instalado, rodar o seguinte comando pelo terminal "sudo mysql -u root -p" ou "mysql -u -root -p".
        Agora, rodando o mysql vamos verificar quais tipos de bancos de dados nela já possui. Bastaria colocar o comando "show databases;".
        Podemos criar um banco de dados tbm usando o comando "create database (nome do banco de dados que vc pode denotar);".
        Agora, para acessar o banco de dados que vc queira bastaria colocar o comando "use (nome do banco de dados existente)".
        Dentro do banco de dados, podemos criar tabelas. Para constar, ao colocarmos o comando "show tables;" mostrará que está vazio.
        Assim, para criar uma tabela podemos digitar "create table (nome da tabela que vc quer criar)<" e isso aparecerá um "->".
        Nela vc coloca os elementos que vão para a tabela, um exemplo, "id_noticias int not null primary key auto_increment,"
        Na próxima linha podemos colocar "titulo varchar<100>,"
        Na terceira linha colocar "noticia text,"
        E na quarta, e última, colocamos "data_criacao timestamp default current_timestamp>;", onde finalmente fechamos o ">" que foi iniciado no começo.
        Obs: Aqui foi usado "<" e ">" para representar os parentes. Mas isso só vale no windows. Para o Linux precisa ser "(" e ")".
        Agora, selecionando uma linha criada "select * from noticias;", vamos ver que essa linha está vazia.
        Assim, para colocar alguma informação precisamos colocar "insert into noticias(titulo, noticias)values('titulo da noticia', 'conteudo da noticia');".
        Novamente, colocar "select * from noticias;" para verificar o que tem dentro de noticias, vamos poder ver que há um registro que foi coloado acima.

    Aula 4 - Criando a conexão com o MySQL e recuperando dados:
        Nessa aula, vamos criar conexão com o banco de dados MySql e de lá realizar a requisição das informações que registramos nela.
        Antes de tudo, precisamos ver se já temos o módulo de mysql instalado no node_modules.
        Agora, no arquivo noticias.js vamos fazer a requisição do banco de dados mysql por lá.
            var mysql = require('mysql');

            var connection = mysql.createConnection({
                host: 'localhost',
                user: 'root',
                password: 'Newton@2512',
                database: 'portal_noticias'
            });

            connection.query('select * from noticias',function(error, result) {
                res.send(result);
            });
        No caso, acima seriam os parâmetros que precisamos para estabelecermos a conexão com o banco de dados MySql e conseguirmos realizar a requisição precisa das informações que consta no banco de dados.

    Aula 5 - EJS - Criando views dinâmicas com JavaScript:
        Agora, vamos criar os views dinâmicas com JavaScript. No caso, no arquivo noticias.js vamos colocar um código res.render, onde ela permite que o arquivo que corresponde a rota definida pelo arquivo noticias.js, consiga acessar e manipular as informações requisitadas pelo banco de dados.
        No caso, o arquivo correspondente é o noticias.ejs e nela, pela tag table, iremos mostrar tais informações que foram requisitadas.

    Aula 6 - Refactoring do método de conexão com o banco de dados MySQL:
        Agora, vamos fazer uma refatoração do método de conexão com o banco de dados MySQL. No caso, note que, a requisição feita para o banco de dados MySQL foi feito isoladamente dentro do arquivo noticias.js. Entretanto, essa conexão com o banco de dados, quando vista para um projeto gigante, não é eficiente, pois sempre que criarmos uma rota será necessário criar uma conexão com o banco de dados.
        No caso, seria mais fácil que somente um arquivo realize a tal conexão com o banco de dados e, nas rotas criadas, chamarmos a conexão sempre que for necessário. Assim, caso o banco de dados acabar indo de local para nuvem, bastaria mudar essa configuração nesse arquivo onde estabelece essa conexão e assim as rotas que chamam a conexão para realizar a tal requisição não será necessário realizar nenhuma alteração. Todas elas estarão vendo na mesma conexão da nuvem.
        O arquivo que será feito isso, estará dentro da pasta config com o nome dbConnection.js. E no arquivo noticias.js iremos pegar a linha
        var mysql = require('mysql');
                
        var connection = mysql.createConnection({
            host: 'localhost',
            user: 'root',
            password: '123456789',
            database: 'portal_noticias'
        });
        que é o que estabelece a conexão com o banco de dados MySQL e iremos transferir para esse arquivo dbConnection.js.
        Por fim, no arquivo noticias.js iremos chamar esse arquivo dbConnection pelo require.

Seção 6 - Uma pausa para recapitular:
    Aula 1:
        Realizar a revisão relendo e confirmando cada passos que foi aprendido até agora nas notas anteriores referente ao assunto abordado da seção anterior!!

Seção 7 - Models e ganhando produtividade com Consign (sucessor do Express-Load):
    Aula 1 - O que é o Consign?:
        Agora, vamos implementar o Consign. No caso, esse recurso ela serve para caso vc tiver um número muito grande de routes para gerenciar. No caso, ela serve para criar tais rotas de forma automática, sem necessidade de criar requires um por um.
        Além disso, ela faz um autoload de views.
    
    Aula 2 - NPM - Instalando o Cosign:
        Entrando no projeto que estamos estudando, curso_node, e basta colocar o comando "npm install consign --save".
        Assim, ao olharmos no node-modules, terá a pasta consign presente.

    Aula 3 - Refactoring do projeto prático portal de notícias com Consign (routes):
        Vamos agora refatorar da nossa aplicação. No caso, vamos fazer o require do consign no arquivo server.js. No caso, como a intenção de usarmos consign está em conseguirmos requisitar os routes e depois colocar tais mudanças no express, é necessário que apliquemos o consign, depois que requisitarmos (require), depois do express.
        Feito os procedimentos acima, no arquivo app.js, podemos desconsiderar as variáveis "var rotaHome", "var rotaFormInclusaoNoticia" e "var rotaNoticias".
        Depois disso, note que, mesmo colocando as rotas que temos, tudo continuará funcionando.
        No caso, vale a pena estudar mais a fundo sobre o consign, pois além dos autoloads de rotas, ela automatiza outras inúmeras funcionalidades tbm!
        https://fabiojanio.medium.com/nodejs-express-cors-consign-autoload-bodyparser-e-compression-na-pr%C3%A1tica-fbfc12e46ff4

    Aula 4 - Refactoring do projeto prático portal de notícias com Consign (banco de dados):
        Vamos, por meio do uso de consign, a aprender a colocar o nosso método de conexão no modo autoloader. No caso, note que, no arquivo noticias.js, nela estamos fazendo um require no banco de dados dbConnection, onde nesse arquivo dbConnection.js, estabelece uma única vez a conexão com o banco de dados MySQL.
        Entretanto, ao termos mais de 40 telas, seria muito trabalhoso ter que toda hora em cada rota chamar esse comando para conseguirmos estabelecer a conexão com o banco de dados. No caso, usando o consign, podemos automatizar isso deixando claro qual tela irá ou não fazer a requisição ao banco de dados.
        Vamos inicialmente mexer no arquivo noticias.js. Em seguida, no arquivo server.js, vamos colocar o método then no consign(). Nela, vamos especificar a pasta config e o arquivo dentro do config, pois o próprio server.js que estamos usando está dentro desse arquivo config e assim vamos estabelecer as rotas que queremos que o banco de dados MySQL seja usado.
        Feito isso, no módulo dbConnection.js nela iremos colocar o rapper. Pois, no formato em que o dbConnection.js está estabelecendo a conexão com o banco de dados, configurado o consign da forma como foi feito acima, sempre que entrarmos em uma tela x, será feito uma requisição do equivalente da quantidade de telas em que colocamos na rota independente se vc está ou não acessando a tela.
        Isso, no ponto de vista de eficiência e custo, é muito ruim, pois significa que o seu computador estará realizando uma requisição descenessária toda hora e, dependendo do caso se vc estiver trabalhando em uma empresa que usa o seu sistema que vc está desenvolvendo, vc estárá causando um custo adicional totalmente desnecessária para a empresa por estar realizando requisições desnecessárias, cada vez que vc acessa qualquer tela do site em que vc estiver desenvolvendo.
        No caso, como funciona esse rapper. Basicamente, vamos criar uma nova variável connMySQL e essa variável vamos retornar ela dentro da função module.export. Sendo que na variável connMySQL vai todas as formas de estabelecer a conexão com o banco de dados como ia antes no module.export.
        Agora, no arquivo noticias.js vamos estabelecer uma conexão de forma diferente. Que seria "var connection = app.config.dbConnection();", isso dentro do app.get.
        Pois assim, eu condiciono de forma que eu acesse o banco de dados somente quando eu acessar a rota noticias.

    Aula 5 - Criando a página de detalhes das notícias:
        Agora, vamos criar uma página onde mostra em detalhe o conteúdo da notícia. Para isso, vamos criar um novo arquivo noticia.js no diretório routes.
        Nesse arquivo criado, vamos estabelecer a conexão com o banco de dados requisitando somente os id`s das notícias que estamos inserindo nela. Daí, vamos exibir isso no arquivo noticia.ejs.
        Daí em noticias.ejs podemos carregar somente o que precisamos.
    
    Aula 6 - Implementando models:
        Vamos agora implementar os models que nos servirá para ajudar na organização dos arquivos. No caso, os models vai nos ajudar a controlar as tabelas que são expressa na tela.
        Para isso, dentro do diretório vamos criar um outro diretório chamado models. E dentro desse subdiretório criamos um arquivo noticiasModel.js.
        Daí, para evitarmos de ter que ficar criando cada model para cada tela, vamos, novamente, usar o consign para automatizarmos esse processo.
        No caso, no arquivo server.js vamos incluir os models dentro do processo com o then, da mesma forma que foi feito para dbConnection.
        Agora, dentro do arquivo noticiasModel.js vamos realizar as exportações que precisamos.
        module.exports = function() {
            this.getNoticias();

            return this;
        }
        No caso, acima está sendo exportado uma função e ela retorna a variável "this".
        Em seguida, no arquivo noticias, vamos criar a variável noticiasModel.
        Criado a tal variável, vamos precisar chamar o getNoticias nela e dentro dela chamar o connection e no callback chamar a function que está sendo feito callback no connection.query.
        noticiasModel.getNoticias(connection, function(error, result) {
            res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
        });
        Isso significa que não vamos mais usar o connection.query no arquivo noticias. Pois isso será feito, somente uma única vez no arquivo noticiasModel.js dentro do this.getNoticias.
        module.exports = function() {

            this.getNoticias = function(connection, callback) {
                connection.query('select * from noticias', callback);
            }

            return this;
        }
        Isso significa que o getNoticias, acaba servindo de uma função única para realizar a requisição.
        Analogamente, realizamos isso em noticia.js criando uma outra função getNoticia em noticiasModel.js.
        Assim, ao olharmos no localhost:3000 e irmos colocando as rotas respectivas de noticias e noticia, tudo estará funcionando como queremos.
        No caso, vimos que o noticiasModel.js serviu de um centro onde podemos definir formas de requisições onde podemos chamar as tais tipos de requisições em respectivas rotas que queremos, em vez de ao criarmos as rotas ficarmos toda hora definindo uma requisição. O que tornaria muito caotico quando tivermos que gerenciar as requisições de um conjunto gigante de números de rotas.
    
    Aula 7 - Opcional - Download dos arquivos portal de notícias:
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos parciais do projeto portal de notícias no estado em que se encontram até a aula anterior.

        Bons estudos ;)

Seção 8 - Recebendo dados de formulários com Body-parser:
    Aula 1 - Criando um formulário de cadastro de notícias:
        Vamos apenas criar um formulário que vai permitir um envio de dados ao servidor. No caso, o arquivo que vamos usar é o formulario_inclusao_noticia.ejs.
        <form action="/noticias/salvar" method="post">
			<label>Título</label>
			<input type="text" id="titulo" name="titulo" placeholder="Título da notícia" />
			<br/>
			<label>Notícia</label>
			<textarea id="noticia" name="noticia" rows="5" cols="30"></textarea>
			<br/>
			<input type="submit" value="Enviar"/>
		</form>

    Aula 2 - Extra - Resolvendo conflitos de encoding:
        Vamos ajustar alguns problemas de encoding. Bastaria ir no Code -> Preferences -> Settings -> Command + f e procurar pela palavra encoding.

    Aula 3 - Extra - Resolvendo conflitos de encoding [SUBLIME TEXT 3]:
        Extra - Resolvendo conflitos de encoding [SUBLIME TEXT 3]
        Para configurar o encoding no Sublime Text 3  abra o menu "Preferences / Settings" conforme imagem abaixo:


        Repare que as preferências do Sublime Text 3 agora estão separadas entre as configurações default (quadrante esquerdo) e as configurações do usuário (quadrante direito).

        As configurações default (quadrante esquerdo) podem ser vistas, mas não podem ser modificadas. Para modificar um comportamento default do Sublime Text 3 você precisará aplicar essa modificação nas configurações do usuário (quadrante direito), para fazer isso basta informar o JSON com os valores atualizados separados por vírgura conforme imagem acima.

        *Basicamente falando, as preferências do usuário sobrescrevem as preferências default do Sublime Text 3.

        Bons estudos.
    
    Aula 4 - Recebendo dados de formulários via POST com Body-parser:
        Vamos querer submeter os textos do formulario_inclusao_noticia.js. No caso, vamos renomear esse arquivo para admin.js e daí criamos uma outra rota dentro desse arquivo.
        app.post('/noticias/salvar', function(req, res) {
            res.send('Chegou na pagina');
        });
        E moldamos para
        app.post('/noticias/salvar', function(req, res) {
            var noticias = req.body;
            res.send(noticias);
        });
        Mas para que a forma como requisitamos o body acima funciona, precisamos que esteja instalado o body-parser.
        Instalando o body-parser "npm install body-parser --save".
        Para conferir se foi ou não instalado, bastaria verificar no package.json e no node_module.
        Assim, precisamos parametrizar o body-parser no express. Para isso, precisamos ir no arquivo server.js e realizar a implementação.
        Lembrando, o body-parser é um tipo de middleware, então ela precisa ficar entre o express e o consign para poder realizar a implementação.
        var express = require('express');
        var consign = require('consign');
        var bodyParser = require('body-parser');

        var app = express();
        app.set('view engine', 'ejs');
        app.set('views', './app/views');

        app.use(bodyParser.urlencoded({extended: true}));

        consign()
            .include('app/routes')
            .then('config/dbConnection.js')
            .then('app/models')
            .into(app);

        module.exports = app;

    Aula 5 - Inserindo registros no banco de dados MySQL:
        No caso, vamos inserindo registros no banco de dados MySQL. No caso, no admin.js, na rota noticias/salvar, será necessário recuperar a conexão.
        Além disso, vamos criar uma nova conexão chamada salarNoticia no arquivo noticiasModel.js, onde, no arquivo admin.js, vamos chamar.
        this.salvarNoticia = function(noticia, connection, callback) {
            // Note que, a forma como fazemos o insert aqui é diferente com o que fizemos pelo terminal.
            // Neste caso é fundamental que o JSON possua como rotulo das variáveis o mesmo nome que as colunas da tabela.
            connection.query('insert into noticias set ? ', noticia, callback)
        }
        app.post('/noticias/salvar', function(req, res) {
        var noticia = req.body;
        // res.send('Chegou na pagina');
        // res.send(noticias);

        // conexao
        // model

        // salvarNoticia
        var connection = app.config.dbConnection();
        var noticiasModel = app.app.models.noticiasModel;

        noticiasModel.salvarNoticia(noticia, connection, function(error, result) {
                res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
            });
        });
        Após isso, podemos visitar a tela formulario_inclusao_noticia e nela add noticia, mas, não será identificado a adição, mas mesmo assim a notícia terá sido incluído direito.
        Bastaria conferir isso visitando o banco de dados MySQL.
        No caso, faltaria ajustar o /noticias/salvar. Resolvemos isso, colocando o redirect.
        noticiasModel.salvarNoticia(noticia, connection, function(error, result) {
            // res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
            res.redirect('/noticias');
        });
        O redirect acima serve para quando vc fazer um refresh da página, não correr o risco de inserir a mesma informação novamente.

Seção 9 - Implementando classes em JavaScript:
    Aula 1 - Classes convencionais x classes JavaScript:
        Vamos aprender a implementar uma classe em JavaScript, assim como eu havia aprendido isso em python. Ou seja, é uma orientacão à objetos.
        Se quiser aprofundar mais ainda na ideia da orientação à objetos, bastaria ler sobre teoria de categoria e/ou revisar sobre POO do curso python que eu fiz!
        No caso, em JS, o formato de classe tem de dois tipos. A de protótipo e a forma clássica similar o que foi visto em python.

    Aula 2 - Refactoring do projeto prático portal de notícias - implementando classes:
        Vamos aplicar o conceito de classes para manipular as informações do banco de dados.
        No caso, em noticiasModel.js faremos essa mudança.
        function Noticias() {

        }

        Noticias.prototype.getNoticias = function(connection, callback) {
            connection.query('select * from noticias', callback);
        }

        Noticias.prototype.getNoticia = function(connection, callback) {
            connection.query('select * from noticias where id_noticia = 2', callback);
        }

        Noticias.prototype.salvarNoticia = function (noticia, connection, callback) {
            connection.query('insert into noticias set ? ', noticia, callback);
        }

        module.exports = function() {

            // this.getNoticias = function(connection, callback) {
            //     connection.query('select * from noticias', callback);
            // }

            // this.getNoticia = function(connection, callback) {
            //     connection.query('select * from noticias where id_noticias = 2', callback);
            // }

            // this.salvarNoticia = function(noticia, connection, callback) {
            //     // Note que, a forma como fazemos o insert aqui é diferente com o que fizemos pelo terminal.
            //     // Neste caso é fundamental que o JSON possua como rotulo das variáveis o mesmo nome que as colunas da tabela.
            //     connection.query('insert into noticias set ? ', noticia, callback)
            // }

            // return this;
            return Noticias;
        }
        Depois disso, no arquivo noticias.js e admin.ja na variável noticiasModel e /noticias/salvar, respectivamente, iremos colocar o operador new.
        var noticiasModel = new app.app.models.noticiasModel;
        var noticiasModel = new app.app.models.noticiasModel;
        Note que, com tais modificações mesmo assim as telas continuam funcionando corretamente.
        Além disso, podemos deixar o código do noticiasModel.js de forma mais clean. Por exemplo, a variável connection que toda hora é chamado em cada prototype.
        Em vez de fazer isso, podemos definir uma única vez dentro da função Noticias e depois apenas os chamá-las em cada prototype que vc queira usar.
        function Noticias(connection) {
            this._connection = connection;
        }

        Noticias.prototype.getNoticias = function(callback) {
            this._connection.query('select * from noticias', callback);
        }

        Noticias.prototype.getNoticia = function(callback) {
            this._connection.query('select * from noticias where id_noticia = 2', callback);
        }

        Noticias.prototype.salvarNoticia = function (noticia, callback) {
            this._connection.query('insert into noticias set ? ', noticia, callback);
        }

        module.exports = function() {

            // this.getNoticias = function(connection, callback) {
            //     connection.query('select * from noticias', callback);
            // }

            // this.getNoticia = function(connection, callback) {
            //     connection.query('select * from noticias where id_noticias = 2', callback);
            // }

            // this.salvarNoticia = function(noticia, connection, callback) {
            //     // Note que, a forma como fazemos o insert aqui é diferente com o que fizemos pelo terminal.
            //     // Neste caso é fundamental que o JSON possua como rotulo das variáveis o mesmo nome que as colunas da tabela.
            //     connection.query('insert into noticias set ? ', noticia, callback)
            // }

            // return this;
            return Noticias;
        }
        Feito a mudaça acima, vamos precisar mudar tbm para o arquivo noticias.js e admin.js a forma como está sendo feito a connection.
        var noticiasModel = new app.app.models.noticiasModel(connection);
        var noticiasModel = new app.app.models.noticiasModel(connection);
        Além disso, precisaria tirar a variável connection em cada função abaixo:
        noticiasModel.getNoticias(function(error, result) {
            res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
        });

        noticiasModel.salvarNoticia(noticia, function(error, result) {
            // res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
            res.redirect('/noticias');
        });
        Analogamente, no arquivo noticia.js.
        Podemos ver com isso que tudo continua funcionando corretamente.
        Vamos mudar o nome do aquivo noticiasModel.js para NoticiasDAO.js. Com isso, vamos ter que mudar para cada arquivo que chamamos esse arquivo.
        function NoticiasDAO(connection) {
            this._connection = connection;
        }

        NoticiasDAO.prototype.getNoticias = function(callback) {
            this._connection.query('select * from noticias', callback);
        }

        NoticiasDAO.prototype.getNoticia = function(callback) {
            this._connection.query('select * from noticias where id_noticia = 2', callback);
        }

        NoticiasDAO.prototype.salvarNoticia = function (noticia, callback) {
            this._connection.query('insert into noticias set ? ', noticia, callback);
        }

        module.exports = function() {

            // this.getNoticias = function(connection, callback) {
            //     connection.query('select * from noticias', callback);
            // }

            // this.getNoticia = function(connection, callback) {
            //     connection.query('select * from noticias where id_noticias = 2', callback);
            // }

            // this.salvarNoticia = function(noticia, connection, callback) {
            //     // Note que, a forma como fazemos o insert aqui é diferente com o que fizemos pelo terminal.
            //     // Neste caso é fundamental que o JSON possua como rotulo das variáveis o mesmo nome que as colunas da tabela.
            //     connection.query('insert into noticias set ? ', noticia, callback)
            // }

            // return this;
            return NoticiasDAO;
        }

Seção 10 - Ganhando produtividade com o Express Validator:
    Aula 1 - Introdução Express Validator:
        Todo dado que é imputado no sistema, ela passa por uma validação de dados.
        No caso, vamos usar o express validator, que é um middleware, que funciona exatamente para validar dados.
        https://programandosolucoes.dev.br/2020/11/10/valida-api-express-validator/
        https://www.freecodecamp.org/portuguese/news/como-simplificar-e-deixar-limpa-a-validacao-de-entrada-na-aplicacao-do-express-js/#:~:text=o%20express%2Dvalidator%20%C3%A9%20um,valida%C3%A7%C3%A3o%20e%20sanitiza%C3%A7%C3%A3o%20do%20validator.

    Aula 2 - NPM- Instalando o Express Validator:
        Vamos instalar o express validator.
        No diretório projeto, bastaria colocar "npm install express-validator --save", mas tome cuidado que essa instalação ela colocará a última versão do express-validator, ao ponto de executar a função dela, após o require, a sintaxe não corresponda ao modo clássico.
        Por hora, para compatibilizar na modificação abaixo coloque "npm install --save express-validator@3.2.0 -E".
        Agora, por ser um middleware, vamos precisar incluir ela  no server.js.
        var expressValidator = require('express-validator');
        app.use(expressValidator());
        OBS: Por algum motivo, no nodemon, ele está mostrando que a forma de execução está inválida...

    Aula 3 - Refactoring do projeto prático portal de notícias com Express Validator:
        Depois que adicionamos o express-validator, vamos refatorar o projeto.
        Pelo terminal, depois que ativado a conexão com o banco de dados, "mysql -u root -p", vamos colocar mais alguns dados no banco de dados portal_noticias criado.
        OBS: Eu estou usando o DBeaver para possibilitar tais alterações diretamente no banco de dados mysql.
        Agora, vamos criar uma tabela que permita validação de mais informações.
        No caso, apenas digite "alter table noticias add column resumo varchar(100);", "alter table noticias add column autor varchar(30);" e "alter table noticias add column data_noticia date;".
        Agora, vamos implementar os campos criados no formulário, form_add_noticia.ejs.
        <label>Resumo</label>
        <input type="text" id="resumo" name="resumo" placeholder="Resumo da notícia" />
        <br/>
        <label>Nome autor</label>
        <input type="text" id="autor" name="autor" placeholder="Autor da notícia" />
        <br/>
        <label>Data dos fatos</label>
        <input type="date" id="data_noticia" name="data_noticia" placeholder="Data da notícia" />
        <br/>
        No arquivo NoticiasDAO.js, no prototype salvarNoticia, podemos colocar um console.log para verificar a noticia que é chamado, mais para verificar se não está acontecendo algum problema de conflito na hora do teste de inclusão.
        NoticiasDAO.prototype.salvarNoticia = function (noticia, callback) {
            console.log(noticia)
            this._connection.query('insert into noticias set ? ', noticia, callback);
        }
        Depois que enviamos uma informação nova, "Estatística" valor add, então no arquivo admin.js e nela vamos nos aproveitar do recurso do express-validator.
        console.log(noticia)
        // Utilizando os recursos do express validator para validação
        req.assert('titulo', 'Título é obrigatório').notEmpty();
        req.assert('resumo', 'Resumo é obrigatório').notEmpty();
        req.assert('resumo', 'Resumo deve conter entre 10 à 100 caracteres.').len(10, 100);
        req.assert('autor', 'Autor é obrigatório').notEmpty();
        req.assert('data_noticia', 'Data é obrigatório').notEmpty().isDate({form: 'YYYY-MM-DD'});
        req.assert('noticia', 'Noticia é obrigatório').notEmpty();

        // Como fazer um teste de validação
        var erros = req.validationErrors();

        if (erros) {
            res.render("admin/form_add_noticia");
            // O fato de dar um return eu faço parar completamente o processo.
            return;
        }
        Agora, tenta testar não satisfazendo alguns dos critérios acima de validação e satisfazendo as validações acima.
        O próximo passo é exibir os erros de validações quando a pessoa estiver preenchendo os dados.

    Aula 4 - Exibindo erros de validação com express-validator:
        Vamos aprender a pegar as infomações de validações e exibi-las para o usuário que estiver preenchendo o campo das informações.
        Inicialmente, no arquivo admin.js, vamos colocar console.log(erros); para verificar que tipo de erro é exibido pelo console.
        Lembrando que o nodemon tbm exibi o console.log.
        Note que, na tela formulario_inclusao_noticia, quando não preenchemos as validações necessárias, o console.log que colocamos é exibido em objeto.
        Daí, podemos passar isso dentro do res.render no admin.js um objeto.
        res.render("admin/form_add_noticia", { validacao: erros });
        Feito isso, no form_add_noticia, podemos imprimir a validação acima em formato de lista.
        <% if(validacao) { %>
			<ul>
				<% for(var i = 0; i < validacao.length; i++) { %>
					<li>
						<%= validacao[i].msg %>
					</li>
				<% } %>
			</ul>
		<% } %>
        No caso, os parâmetros que são exibidos são os que foram mostrado no console.log(erros).

    Aula 5 - Mantendo o preenchimento do formulário:
        Vamos aprender a manter as informações preenchidas, mesmo que não preenchemos todos os campos de forma validada.
        Mas antes disso, note que a tela formulario_inclusao_noticia não está reconhecendo o parâmetro "validacao" que foi colocado no form_add_noticia.ejs.
        No caso, para corrigir esse erro, bastaria irmos no arquivo admin.js e no res.render('admin/form_add_noticia'); acrescentar um parâmetro objeto.
        res.render('admin/form_add_noticia', {validacao: {} });
        Feito a mudança acima, podemos visitar a tela formulario_inclusao_noticia novamente.
        Agora, quando colocamos as informações para notícia, mesmo que não preenchido todas elas de forma validada, como mantermos as informações preenchidas mantidas?
        No caso, bastaríamos usar no arquivo admin.js e nela acrescentarmos mais um parâmetro dentro do objeto que foi colocado no res.render("admin/form_add_noticia", { validacao: erros }); junto com a validacao.
        res.render("admin/form_add_noticia", { validacao: erros, noticia: noticia });
        Donde a noticia é a variável noticia que é igual ao body.
        Em seguida, no arquivo form_add_noticia.ejs colocamos nos values para o valores que aparecem em js.
        <form action="/noticias/salvar" method="post">
			<label>Título</label>
			<input type="text" id="titulo" name="titulo" value="<%=noticia.titulo%>" placeholder="Título da notícia" />
			<br/>
			<label>Resumo</label>
			<input type="text" id="resumo" name="resumo" value="<%=noticia.resumo%>" placeholder="Resumo da notícia" />
			<br/>
			<label>Nome autor</label>
			<input type="text" id="autor" name="autor" value="<%=noticia.autor%>" placeholder="Autor da notícia" />
			<br/>
			<label>Data dos fatos</label>
			<input type="date" id="data_noticia" name="data_noticia" value="<%=noticia.data_noticia%>" placeholder="Data da notícia" />
			<br/>
			<label>Notícia</label>
			<textarea id="noticia" name="noticia" value="<%=noticia.noticia%>" rows="5" cols="30"></textarea>
			<br/>
			<input type="submit" value="Enviar"/>
		</form>
        Assim, mesmo que vc coloque as informações de forma que não seja validado, as abas preenchidas terão sido todas elas preenchidas.
        O mesmo parâmetro "noticia" que foi colocado no res.render("admin/form_add_noticia", { validacao: erros });, deverá ser colocado em res.render('admin/form_add_noticia', {validacao: {} });, pois se não, novamente, a tela de formulario_inclusao_noticia não será possível acessar.
        res.render('admin/form_add_noticia', {validacao: {}, noticia: {} });


Seção 11 - Implementando controllers e entendendo o designer pattern MVC:
    Aula 1 - Implementando controllers:
        Vamos implementar os controllers para melhor arquitetura da nossa aplicação.
        No momento, quem está fazendo o papel de controller são as rotas. 
        Por início, vamos olhar para os dois arquivos noticia.js e noticias.js e passar o conteúdo de noticia.js dentro de noticias.js.
        Isso faz sentido, pois no subdiretório noticias do diretório view se encontram dois arquivos noticia.ejs e noticias.ejs.
        Daí o arquivo noticia.js podemos excluir.
        Agora, vamos implementar o nosso controller.
        No caso, dentro do diretório app vamos criar um novo diretório controllers.
        Dentro do diretório controllers, criamos mais um arquivo chamado admin.js.
        Agora, em parelelo com o arquivo admin.js que está dentro da pasta routes, vamos indo criar os controllers.
        Daí, no arquivo server.js precisamos dizer que os arquivos do routes estão implementandos as funcionalidades de controllers, com ajuda de consign.
        consign()
            .include('app/routes')
            .then('config/dbConnection.js')
            .then('app/models')
            .then('app/controllers')
            .into(app);
        E dentro do admin.js do diretório routes colocamos a aplicação que fizemos no controllers.
        app.get('/formulario_inclusao_noticia', function(req, res) {
            // res.render('admin/form_add_noticia', {validacao: {}, noticia: {} });
            app.app.controllers.admin.formulario_inclusao_noticia(app, req, res);
        });
        A princípio, parece que colocamos mais códigos comparado ao formato como estava antes.
        Mas, seguindo a mesma implementação feita acima, vamos fazer para a tela "noticias/salvar" para verificarmos como vai ficar.
        Assim, em admin.js do controllers resultará.
        module.exports.formulario_inclusao_noticia = function(app, req, res) {
            res.render('admin/form_add_noticia', {validacao: {}, noticia: {} });
        }

        module.exports.noticias_salvar = function(app, req, res) {
            var noticia = req.body;
            // res.send('Chegou na pagina');
            // res.send(noticias);

            // conexao
            // model

            // Utilizando os recursos do express validator para validação
            req.assert('titulo', 'Título é obrigatório').notEmpty();
            req.assert('resumo', 'Resumo é obrigatório').notEmpty();
            req.assert('resumo', 'Resumo deve conter entre 10 à 100 caracteres.').len(10, 100);
            req.assert('autor', 'Autor é obrigatório').notEmpty();
            req.assert('data_noticia', 'Data é obrigatório').notEmpty().isDate({form: 'YYYY-MM-DD'});
            req.assert('noticia', 'Noticia é obrigatório').notEmpty();

            // Como fazer um teste de validação
            var erros = req.validationErrors();

            // console.log(erros);

            if (erros) {
                res.render("admin/form_add_noticia", { validacao: erros, noticia: noticia });
                // O fato de dar um return eu faço parar completamente o processo.
                return;
            }

            // salvarNoticia
            var connection = app.config.dbConnection();
            // var noticiasModel = app.app.models.noticiasModel;
            var noticiasModel = new app.app.models.NoticiasDAO(connection);

            // noticiasModel.salvarNoticia(noticia, connection, function(error, result) {
            //     // res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
            //     res.redirect('/noticias');
            // });

            noticiasModel.salvarNoticia(noticia, function(error, result) {
                // res.render("noticias/noticias", {noticias: result});  // Basicamente, essa condição vai nos permitir acessar as informações dos arrays pelo arquivo .ejs correspondente dessa rota.
                res.redirect('/noticias');
            });
        }
        E no arquivo admin.js do routes resultará no seguinte.
        module.exports = function (app) {
            app.get('/formulario_inclusao_noticia', function(req, res) {
                // res.render('admin/form_add_noticia', {validacao: {}, noticia: {} });
                app.app.controllers.admin.formulario_inclusao_noticia(app, req, res);
            });

            // Esse código aqui não vai funcionar pois ele está na requisição get, sendo que foi definido, pelo form_add_noticia.ejs em form, uma requisição via post.
            // app.get('/noticias/salvar', function(req, res) {
            //     res.send('Chegou na pagina');
            // });

            app.post('/noticias/salvar', function(req, res) {
                app.app.controllers.admin.noticias_salvar(app, req, res);
            });
        };
        Feito essa mudança, note que, tudo ainda estará funcionando normalmente.
        A mesma lógica podemos implementar para outros arquivos .js que estão no routes.
        No caso, iremos fazer isso para noticias.js e home.js
        Veremos que mesmo assim, tudo continua funcionando normalmente.

    Aula 2 - Designer pattern Model-View-Controller (MVC):
        https://www.geeksforgeeks.org/mvc-design-pattern/
        http://www.linhadecodigo.com.br/artigo/2367/abordando-a-arquitetura-mvc-e-design-patterns-observer-composite-strategy.aspx
        https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller

    Aula 3 - Opcional - Download dos arquivos portal de notícias:
        Opcional - Download dos arquivos portal de notícias
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos parciais do projeto portal de notícias no estado em que se encontram até a aula anterior.

        Bons estudos ;)

Seção 12 - Utilizando recursos estáticos como imagens, arquivos de estilo e scripts:
    Aula 1 - Download de HTMLs e assets do projeto prático portal de notícias:
        Download de HTMLs e assets do projeto prático portal de notícias
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos HTMLs e assets para darmos continuidade ao desenvolvimento do projeto prático portal de notícias.

        Bons estudos ;)

    Aula 2 - Incluindo recursos estáticos:
        Primeiro:
            Criamos um novo diretório, dentro do diretório app, com o nome public.
            Dentro desse diretório, colocamos as pastas css, image e js, do arquivo portal_noticias_html_e_assets.

        Segundo:
            Pegamos o arquivo index.html, da pasta portal_noticias_html_e_assets, e copiamos todos os conteúdos dela e sobrescrevemos o conteúdo do arquivo index.ejs que está no diretório home.
        
        Terceiro:
            No server.js vamos mapear os arquivos necessários em que aparece como erro no console da página home.
            app.use(express.static('./app/public'));

        Quarto:
            Pegamos o arquivo form_add_noticia.ejs que está no diretório admin e nela sobrescrevemos com todos os conteúdos do arquivo formulario_inclusao_noticia.html da pasta portal_noticias_html_e_assets.
            A mesma coisa faremos para os dois arquivos notícias.ejs e noticia.ejs.

        Assim, teminamos as refatorações necessárias da contruição de todo o visual.

    Aula 3 - Reaplicando a lógica de back-end - parte 1:
        Vamos aplicar toda a regra de back-end que aprendemos até agora para esse novo layout do nosso projeto.
        No caso, no arquivo home.js, vamos criar uma conexão que precisamos
        var connection = app.config.dbConnection();
        var noticiasModel = new app.app.models.NoticiasDAO(connection);

        noticiasModel.get5UltimasNoticias(function(error, result) {
            console.log(result);
            res.render("home/index", {noticias: result});
        });

        Assim, em NoticiasDAO definimos o protótipo get5UltimasNoticias.
        NoticiasDAO.prototype.get5UltimasNoticias = function (callback) {
            this._connection.query('select * from noticias order by data_criacao desc limit 5', callback);
        }

        Agora, no arquivo index.ejs, vamos identar o código js dentro do html chamando as alterações que fizemos acima.
        <div class="row">
            <div class="col-md-8">
                <div class="noticia_wrapper">
                    <span class="noticia_autor"><%= noticias[0].autor %></span>
                    <a href="noticia.html" class="noticia_titulo"><%= noticias[0].titulo %></a>
                    <span class="noticia_data"><%= noticias[0].data_noticia %></span>
                    <br />
                    <p class="noticia_resumo">
                        <%= noticias[0].resumo %>
                    </p>
                </div>
            </div>

            <div class="col-md-4">
                <div class="noticia_wrapper">
                    <span class="noticia_autor"><%= noticias[1].autor %></span>
                    <a href="noticia.html" class="noticia_titulo">"><%= noticias[1].titulo %></a>
                    <span class="noticia_data"><%= noticias[1].data_noticia %></span>

                    <br />
                    <p class="noticia_resumo">
                        <%= noticias[1].resumo %>
                    </p>
                </div>
            </div>
        </div>

        <div class="row">
            <% for(var i = 2; i < noticias.length; i++) { %>
                <div class="col-md-4">
                    <div class="noticia_wrapper">
                        <span class="noticia_autor"><%= noticias[i].autor %></span>
                        <a href="noticia.html" class="noticia_titulo"><%= noticias[i].noticia %></a>
                        <span class="noticia_data"><%= noticias[i].data_noticia %></span>
                        <br />
                        <p class="noticia_resumo">
                            <%= noticias[i].resumo %>
                        </p>
                    </div>
                </div>
            <% } %> 
        </div>

    Aula 4 - Reaplicando a lógica de back-end - parte 2:
        Vamos agora trabalhar com o formulario_inclusao_noticia.
        No caso, o arquivo form_add_noticia.ejs vamos precisar colocar o action no form.
        <form action="/noticias/salvar" method="post">
        Só para conseguirmos linkar com a rota definido no admin.js do routes.
        Novamente, vamos colocar as condicionais do expressValidator para avisar o que precisa ser ou não preenchido corretamente no formulario_inclusao_noticia.
        Então, no arquivo form_add_noticia.ejs.
        <% if (validacao.length > 0) { %>
            <div class="row">
                <div class="col-md-12">
                    <div class="alert alert-danger">
                        <strong>Atenção!</strong>
                        <ul>
                            <% for(var i = 0; i < validacao.length; i++) { %>
                                <li><%= validacao[i].msg %></li>
                            <% } %>
                        </ul>
                    </div>
                </div>
            </div>
        <% } %>

    Aula 5 - Reaplicando a lógica de back-end - parte 3:
        No caso, vamos implementar o que precisa vir em noticias.ejs.
        <div class="container">
			<% if(noticias.length > 0) { %>
				<% for(var i = 0; i < noticias.length; i++) { %>
					<div class="row">
						<div class="col-md-12">
							<div class="noticia_wrapper">
								<span class="noticia_autor"><%= noticias[i].autor %></span>
								<a href="noticia.html" class="noticia_titulo"><%= noticias[i].titulo %></a>
								<span class="noticia_data"><%= noticias[i].data_noticia %></span>
								<br />
								<p class="noticia_resumo">
									<%= noticias[i].resumo %>
								</p>
							</div>
						</div>
					</div>
				<% } %>
			<% } %>
	    </div>
        Além disso, note que, ao visitarmos a tela /noticias, a ordem de exibição delas estarão em ordem crescente. Precisamos colocar em ordem decrescente e para isso precisamos alterar o protótipo getNoticias do NoticiasDAO.js.
        NoticiasDAO.prototype.getNoticias = function(callback) {
            this._connection.query('select * from noticias order by data_criacao desc', callback);
        }

        Além disso, note que, na tela /noticias em cada tabela de exibição está sendo possível clicar nelas para serem direcionadas na página noticia.html.
        Entretanto, no formato como está agora não será possível isso, pois no momento está fixa. Na próxima aula vamos dinamiza-los.
        Mas, por hora, no arquivo noticias.ejs, bastaria apagar o .html no href.
        <a href="noticia" class="noticia_titulo"><%= noticias[i].titulo %></a>
        O mesmo para noticias.html, do index.ejs.

        Agora, no arquivo noticia.ejs, por hora, vamos fazer o seguinte.
        <div class="container">
	    	<div class="row">
	    		<div class="col-md-12">
	    			<div class="noticia_wrapper">
		    			<span class="noticia_autor"><%= noticia[0].autor %></span>
		    			<a href="noticia/1" class="noticia_titulo"><%= noticia[0].titulo %></a>
		    			<span class="noticia_data"><%= noticia[0].data_noticia %></span>
		    			<br />
		    			<p class="noticia_resumo">
		    				<%= noticia[0].resumo %>
		    			</p>
		    		</div>
		    	</div>
	    	</div>
	    </div>

    Aula 6 - Enviando e recebendo parâmetros (request.query):
        Vamos customizar a tela noticias.ejs e index.ejs.
        No index.ejs, vamos colocar a alteração seguinte:
            href="noticia?id_noticia=<%= noticias[0].id_noticias %>"
        Faremos isso, analogamente, para outras tags do mesmo arquivo index.ejs.

        Outra alteração que vamos fazer é no arquivo noticias.ejs, o mesmo que foi feito para o index.ejs acima.
            <div class="container">
                <% if(noticias.length > 0) { %>
                    <% for(var i = 0; i < noticias.length; i++) { %>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="noticia_wrapper">
                                    <span class="noticia_autor"><%= noticias[i].autor %></span>
                                    <a href="noticia?id_noticia=<%= noticias[i].id_noticias %>" class="noticia_titulo"><%= noticias[i].titulo %></a>
                                    <span class="noticia_data"><%= noticias[i].data_noticia %></span>
                                    <br />
                                    <p class="noticia_resumo">
                                        <%= noticias[i].resumo %>
                                    </p>
                                </div>
                            </div>
                        </div>
                    <% } %>
                <% } %>
            </div>
        
        Além disso, no noticias.js que está no controller, vamos colocar o console.log no module.export.noticia para verificar o que está sendo devolvido na requisição/request (req).
        Note que, no console.log, quando filtramos a busca do req pelo query, podemos ver que nela mostra exatamente o índice que é selecionado quando aparece no path.
        Logo, com essa query, podemos mandar esse índice para a função getNoticia.

            var id_noticia = req.query;
            // console.log(req.query);

            noticiasModel.getNoticia(id_noticia, function(error, result) {
                res.render("noticias/noticia", {noticia: result});
            });
        
        Agora, em NoticiasDAO.js, no protótipo getNoticia definido, podemos passar dentro dela o parâmetro id_noticia que foi definido.

            NoticiasDAO.prototype.getNoticia = function(id_noticia, callback) {
                console.log(id_noticia.id_noticia);
                this._connection.query('select * from noticias where id_noticias = ' + id_noticia.id_noticia, callback);
            }

        Assim, tanto a tela de noticias quanto a tela de home estão ajustados.
        
    Aula 7 - Opcional - Download dos arquivos portal de notícias:
        Opcional - Download dos arquivos portal de notícias
        Utilize o link disponibilizado como recurso dessa aula para fazer o download do projeto portal de notícias completo.

        Bons estudos ;)

Seção 13 - Projeto prático - Multiroom Chat real-time com WebSocket:
    Aula 1 - Preparando dependências e diretórios do app:
        Vamos preparar um novo projeto chamado Multiroom Chat Real-time.
        Vamos criar um ditetório novo chamado multiroom_chat.
        As notas de aulas serão transferidas para esse novo diretório.
        Vamos precisar instalar os mesmos módulos que usamos no projeto curso_node pelo npm.
        Vamos seguir os passos a passos burocráticos abaixo:
        1-) Criamos um diretório com o nome do projeto.
        2-) Vamos rodar o comando "npm init", no caso, isso permitirá criar o package.json.
        3-) Instalar o express, "npm install express@4.15.3 --save", com o "--save" incluso isso criará o package-lock.json e o node_modules.
            Obs: Caso vc rodar apenas "npm install express --save", será instalado a última versão do express validator e isso pode ser que mude a regra de como deve ser importado.
        4-) Instalar o ejs, "npm install ejs@2.5.6 --save".
            Obs: Caso vc rodar apenas "npm install ejs --save", será instalado a última versão do express validator e isso pode ser que mude a regra de como deve ser importado.
        5-) Instalar o consign, "npm install consign@0.1.6 --save".
            Obs: Caso vc rodar apenas "npm install consign --save", será instalado a última versão do express validator e isso pode ser que mude a regra de como deve ser importado.
        6-) Vamos instalar o body-parser, que é o nosso middleware, "npm install body-parser@1.17.2 --save".
            Obs: Caso vc rodar apenas "npm install body-parser --save", será instalado a última versão do express validator e isso pode ser que mude a regra de como deve ser importado.
        7-) Instalar o express-validator, que é o módulo que valida, "npm install --save express-validator@3.2.0 -E".
            Obs: Caso vc rodar apenas "npm install express-validator --save", será instalado a última versão do express validator e isso pode ser que mude a regra de como deve ser importado.

        Assim, temos todos os módulos que precisamos.

        Agora, vamos criar as estruturas que vamos precisar nesse projeto.
        1-) Vamos criar o diretório config e dentro dela o arquivo server.js.
        2-) Criamos o arquivo app.js no diretório raiz, que servirá de entry point.
        3-) Criamos o diretório app, no diretório raiz, e dentro dela criamos os subdiretórios controllers, models, public, routes e views.
        4-) Dentro do diretório public, vamos criar os diretórios css, images e js.

        Com isso, no nosso novo projeto, instalamos os módulos que precisamos e criamos as estruturas que serão necessárias para ela.
        Ou seja, o ambiente para começarmos a desenvolver está pronto!


    Aula 2 - Configurando o servidor:
        Vamos configurar, agora, o nosso servidor.
        Vamos seguir os seguintes passos:
        1-) No app.js vamos importar as configurações do servidor.
            // Importar as configurações do servidor
            // Lembrando que na importaçào do módulo, podemos ocultar a extensão. Ou seja, não precisa colocar .js.
            var app = require('./config/server');

            // Vamos parametrizar a porta de escuta
            app.listen(80, function() {
                console.log('Servidor Online');
            })
        
        2-) No arquivo server.js, vamos configurar algumas importações.
            // Importar o módulo do framework express
            var express = require('express');

            // Importar o módulo do consign
            var consign = require('consign');

            // Importar o módulo do body-parser
            var bodyParser = require('body-parser');

            // Importar o módulo de express-validator

            var expressValidator = require('express-validator');

            // Iniciar o objeto express
            var app = express();

            // Setar as variáveis 'view engine'e 'views' do express
            app.set('view engine', 'ejs');
            app.set('views', './app/views');

            // Configurar o middleware express.static
            app.use(express.static('./app/public'));

            // Configurar o middleware body-parser
            app.use(bodyParser.urlencoded({extended: true}));

            // Configurar o middleware express-validator
            app.use(expressValidator());

            // Efetuando o autoload das rotas, models e dos controllers para o objeto app
            consign()
                .include('app/routes')
                .then('app/models')
                .then('app/controllers')
                .into(app)

            // Exportando o objeto app
            module.exports = app;
        
        3-) Feitas as etapas acima, vamos subir o servidor para verificar se tudo está funcionando como esperamos.
        Bastaria rodar o comando dentro do diretório pelo terminal "nodemon app". Daí, em uma nova aba de navegação podemos colocar apenas o localhost, sem especificar a porta 80, pois o próprio broswer possui uma parametrização que indica a porta 80.
        Se aparecer algo do gênero Cannot GET/, significa que deu certo.

            Obs: Haverá casos em que vc não irá conseguir rodar isso. Ou seja, quando vc colocar o comando nodemon app aparecerá o seguinte erro, ou algo parecido, abaixo:
                [nodemon] 2.0.20
                [nodemon] to restart at any time, enter `rs`
                [nodemon] watching path(s): *.*
                [nodemon] watching extensions: js,mjs,json
                [nodemon] starting `node app`
                internal/modules/cjs/loader.js:905
                throw err;
                ^

                Error: Cannot find module '/config/server.js'
                Require stack:
                - /home/leonardo/Documentos/estudos/multiroom_chat/app.js
                    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:902:15)
                    at Function.Module._load (internal/modules/cjs/loader.js:746:27)
                    at Module.require (internal/modules/cjs/loader.js:974:19)
                    at require (internal/modules/cjs/helpers.js:93:18)
                    at Object.<anonymous> (/home/leonardo/Documentos/estudos/multiroom_chat/app.js:3:11)
                    at Module._compile (internal/modules/cjs/loader.js:1085:14)
                    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)
                    at Module.load (internal/modules/cjs/loader.js:950:32)
                    at Function.Module._load (internal/modules/cjs/loader.js:790:12)
                    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12) {
                code: 'MODULE_NOT_FOUND',
                requireStack: [ '/home/leonardo/Documentos/estudos/multiroom_chat/app.js' ]
                }

                No caso, uma das possibilidades para corrigir esse erro seria que vc não está como um usuŕio privilegiado para acessar a porta 80. (https://stackoverflow.com/questions/60372618/nodejs-listen-eacces-permission-denied-0-0-0-080)
                Logo, uma das alternativas que serviria para corrigir esse tipo de erro seria vc usar o comando "sudo -s" e acessando o diretório projeto estando como root vc instala o nodemon, "npm install -g nodemon --save".


        4-) Por vias das dúvidas, podemos ir no diretório routes e dentro dela vamos criar um arquivo index.js e dentro dela vamos exportar um módulo.
            module.exports = function(application) {
                application.get('/', function(req, res) {
                    res.send('Teste');
                })
            }
            Assim, no localhost, deverá aparecer a msg "Teste".

    Aula 3 - Download de arquivos estáticos (assets) e HTML:
        Download de arquivos estáticos (assets) e HTML
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos HTMLs e assets do projeto Multiroom Chat.

        Bons estudos ;)

    Aula 4 - Ajustando routes e views:
        Pegamos o projeto com frontEnd pronto, multiroom_chat_arquivos_do_projeto, que podemos pegar da aula anterior e implementamos-as dentro do nosso projeto.
        No caso, dentro do diretório public no diretório css, images e js, dentro delas, colocamos os arquivos presentes que estão nos respectivos diretórios com o mesmos nomes que vc encontra no multiroom_chat_arquivos_do_projeto.
        Agora, os dois arquivos htmls, index.html e chat.html, ambos irão para o diretório views do nosso projeto, multiroom_chat.
        Enviado todos os arquivos que precisávamos para darmos continuidade no nosso projeto, agora vamos pegar o arquivo index.js que está dentro do diretório routes e iremos substituir o .send para .render e dentro dela colocar o index.html para rodarmos.
            module.exports = function(application) {
                application.get('/', function(req, res) {
                    // res.send('Teste');
                    res.render('index');
                })
            }
        No caso, como estamos usando a extensão ejs, então os dois arquivos htmls que enviamos ao nosso projeto, index.html e chat.html, que estão dentro do diretório views, precisamos mudar a extensão delas para ejs.
        Feito isso, no broswer, bastaria rodar localhost, sem especificar a porta 80, que nela irá renderizar o arquivo index.ejs que chamamos.
        Note que, da msg "Teste" mudou para uma tela de entrada para sala de chat.

        Vamos, agora, fazer o processo análogo para o chat tbm. No caso, dentro do diretório routes, vamos criar o arquivo chat.js e dentro dele criar uma requisição get e post, pois, esta última, o que está sendo exibido na tela index.ejs será feito uma submissão para podermos entrar na tela de chat e realizar as conversas.
            module.exports = function(application) {
                application.post('/chat', function(req, res) {
                    // res.send('Teste');
                    res.render('chat');
                })

                application.get('/chat', function(req, res) {
                    // res.send('Teste');
                    res.render('chat');
                })
            }
        No caso, mesmo feito acima no arquivo chat.js, como tela index.ejs não foi configurado para realizar a submissão, então mesmo colocando o nosso nome e cliando em entrar não acontecerá nada. No rota, irá aparecer http://localhost/?.


    Aula 5 - Ajustando routes e controllers:
        Nessa aula, daremos continuidade para refatoração. Na última aula fizemos isso em routes e views.
        Já agora, continuaremos a dar atenção ao routes e, desta vez de novo, iremos dar atenção ao controllers.
        No diretório controllers, vamos criar dois arquivos, index.js e chat.js.
        No index.js, do diretório controllers, vamos exportar um módulo.
            module.exports.index = function(application, req, res) {
                res.render("index");
            }
        No caso, feito isso, vamos precisar alterar o index.js de routes, pois o controllers, como foi estudado antes, serve para conseguir controlar os tipos de arquivos que serão exportados e que receberão as requisições pelo routes.
        Basicamente, enquanto que no controllers vc define a função o routes ele executa ela.
            module.exports = function(application) {
                application.get('/', function(req, res) {
                    // res.send('Teste');
                    // res.render('index');
                    application.app.controllers.index.index(application, req, res)
                })
            }
        Se atualizarmos a página, vamos ver que tudo continua funcionando corretamente.
        Realizamos o mesmo processo para o controllers do chat.js.
        No caso, no chat.js do controllers:
            module.exports.iniciaChat = function(application, req, res) {
                res.render('chat');
            }
        Já no chat.js de routes, colocamos:
            module.exports = function(application) {
                application.post('/chat', function(req, res) {
                    // res.send('Teste');
                    // res.render('chat');
                    application.app.controllers.chat.iniciaChat(application, req, res);
                })

                application.get('/chat', function(req, res) {
                    // res.send('Teste');
                    // res.render('chat');
                    application.app.controllers.chat.iniciaChat(application, req, res);
                })
            }
        Feito isso, ao visitarmos a tela chat, localhost/chat, vamos ver que tudo continua funcionando normalmente.

    Aula 6 - Recebendo e validando os dados do formulário de entrada:
        Vamos aprender a aplicar as lógicas dentro do controllers.
        Primeira coisa que vamos fazeré configurar o nosso formulário. No caso, no arquivo index.ejs do views, vamos colocar o seguinte:
            <form accept-charset="UTF-8" role="form" class="form-signin" action="/chat" method="post">
                <fieldset>
                    <label class="panel-login">
                        <div class="login_result"></div>
                    </label>
                    <input class="form-control" placeholder="Nome ou apelido" id="apelido" type="text">
                    <br></br>
                    <input class="btn btn-lg btn-success btn-block" type="submit" id="entrar" value="Entrar »">
                </fieldset>
            </form>
        No caso, com essa mudança acima, independentemente se eu coloquei ou não algum nome, ao clicarmos no Entrar seremos direcionado diretamente na tela de chat.
        No caso, não é o que queremos. Precisamos colocar algumas restrições para isso. Então iremos usar o express-validator, o middleware.
        Para isso, vamos pegar o arquivo chat.js do controllers e nela realizar tais implementações.
            module.exports.iniciaChat = function(application, req, res) {
                var dadosForm = req.body;

                console.log(dadosForm);
                res.render('chat');
            }
        A implementação acima mostrará o que irá ser entregue em json quando clicarmos no Entrar. No estado atual em que estamos o formulário do index.ejs, ao clicarmos no Entrar, sem que coloquemos nenhum nome, pelo console será mostrado um objeto json vazio.
        Ou seja, rodando o nodemon, será mostrado "{}".
        Para evitarmos isso, no index.ejs, vamos precisar configurar algumas coisa na tag input que está dentro da tag form.
            <input class="form-control" placeholder="Nome ou apelido" id="apelido" name="apelido" type="text">
        Colocado name="apelido" na tag acima, vamos conseguir ver que ao colocarmos o próprio nome no formulário isso será expresso pelo console um objeto com elemento apelido dentro.
        Agora que conseguimos colocar as variáveis que servirão para condicionar a loǵica, vamos realizar a tal implementação lógica.
        No caso, no chat.js vamos colocar o seguinte:
            module.exports.iniciaChat = function(application, req, res) {
                var dadosForm = req.body;

                // console.log(dadosForm);
                req.assert('apelido', 'Nome ou apelido é obrigatório!').notEmpty();
                req.assert('apelido', 'Nome ou apelido deve conter entre 3 à 15 caracteres!').len(3,15);

                var erros = req.validationErrors();

                if(erros) {
                    res.send('Existem erros no formulário!');
                    return;
                }

                res.render('chat');
            }
        No formato acima, quando colocado algum erro no formulário, será exibido a msg "Existem erros no formulário!", apenas. Precisamos, no caso, enviar tais msgs que erros da própria tela do formulário explicitamente para o usuário.
        No caso, no chat.js do controllers, vamos aplicar:
            module.exports.iniciaChat = function(application, req, res) {
                var dadosForm = req.body;

                // console.log(dadosForm);
                req.assert('apelido', 'Nome ou apelido é obrigatório!').notEmpty();
                req.assert('apelido', 'Nome ou apelido deve conter entre 3 à 15 caracteres!').len(3,15);

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao: erros});
                    // res.send('Existem erros no formulário!');
                    return;
                }

                res.render('chat');
            }
        Em seguida, no index.ejs, vamos criar uma nova div em que será expressado essas msgs de erros.
            <div>
                <% if(validacao.length > 0) {%>
                    <div class="row">
                        <div class="col-md-12">
                            <div class="alert">
                                <strong>Atenção!</strong>
                                <ul>
                                    <% for(var i = 0; i < validacao.length; i++) {%>
                                        <li><%=validacao[i].msg%></li>
                                    <% } %>
                                </ul>
                            </div>
                        </div>
                    </div>
                <% }%>
            </div>
        A implementação acima, não será o suficiente, pois como estamos usando uma variável dentro do index.ejs, precisamos, primeiramente, definir essa variável dentro do index.js do controllers.
            module.exports.index = function(application, req, res) {
                res.render("index", {validacao: {}});
            }

    Aula 7 - Introdução a Websocket e Socket.IO:
        Vamos aprender, inicialmente, o conceito de Socket, Websocket e Socket.io.
        https://socket.io/docs/v4/
        https://cursos.alura.com.br/forum/topico-diferenca-entre-socket-e-websocket-70527
        https://pt.stackoverflow.com/questions/46839/o-que-s%C3%A3o-sockets-de-rede-e-websockets
        https://stackoverflow.com/questions/10112178/differences-between-socket-io-and-websockets

    Aula 8 - NPM - Instalando o Socket.IO:
        Vamos precisar instalar o Socket.io via npm.
        No caso, vamos precisar rodar o comando "npm install socket.io@2.0.3 --save".
            Obs: se rodarmos apenas npm install socket.io --sabe, irá baixar a última versão.

    Aula 9 - Refactoring do Multiroom Chat - Integrando o Socket.IO ao servidor NodeJS:
        Feito a instalação do socket.io, vamos realizar uma refatoração nessa aula integrando o socket.i o instalado.
        No caso, no arquivo app.js que está na raiz, precisamos realizar a seguinte implementação:
            // Importar as configurações do servidor
            // Lembrando que na importaçào do módulo, podemos ocultar a extensão. Ou seja, não precisa colocar .js.
            var app = require('./config/server.js');

            // Vamos parametrizar a porta de escuta
            var server = app.listen(80, function() {
                console.log('Servidor Online');
            })

            require('socket.io').listen(server);
        No caso, a implementação acima, meio qua, cria um gancho com a requisição HTTP, da porta 80, com o HTTP do socket.io.
        No caso, agora o nosso servidor responde à dois protocolos diferentes na mesma porta 80.

    Aula 10 - Abrindo a conexão via websocket:
        Vamos configurar o websocket do lado do cliente.
        No caso, no chat.ejs, vamos configurar o seguinte:
            <script src="/socket.io/socket.io.js"></script>
        O script implementado acima configura tudo o que precisa para o cliente escutar e emitir msgs.
        Ao entrarmos no chat com algum apelido ou nome e abrirmos o console e irmos ao Sources, nela será mostrado que tem o diretório socket.io e dentro dela o arquivo socket.io.js com o código tudo configurado.
        Isso significa que os recursos do socket.io foi implementado tanto pelo broswer em que estamos usando quando no nosso servidor.
        Isso significa que, agora, podemos começar a trocar msgs para estabelecer um protocolo de comunicação.
        Novamente, no chat.ejs, abaixo do script que criamos vamos criar um outro script, visto que é js que estamos usando e nela iremos implementar as funções necessárias.
            <script>
                var socket = io('http://localhost');
            </script>
        Como, antes, temos o script do socket.io, podemos usar um recurso do socket chamado "io", como foi feito acima, para estabelecermos a comunicação com o lado do cliente.
        Agora, iremos realizar isso para o lado do servidor.
        Para isso, iremos mexer no arquivo app.js e iremos colocar o seguinte dentro dela.
            // Importar as configurações do servidor
            // Lembrando que na importaçào do módulo, podemos ocultar a extensão. Ou seja, não precisa colocar .js.
            var app = require('./config/server.js');

            // Vamos parametrizar a porta de escuta
            var server = app.listen(80, function() {
                console.log('Servidor Online');
            })

            var io = require('socket.io').listen(server);

            // Criar conexão por websocket.

            io.on('connection', function(socket){
                console.log('Usuário conectou!');
            });
        No caso, foi feito a mesma função "io" acima, como temos tbm no lado do cliente, precisou-se definir para o lado do servidor tbm.
        Além disso, a função "on" que foi usada acima ela é o que estabelece a comunicação com o cliente. No caso, escuta o cliente e o servidor, vice e versa.
        No caso, o console.log acima será um indicativo de que conseguimos realizar o disparo de io pelo lado do servidor e que será expresso pelo terminal.
        Além do evento da conexão, existe tbm o evento da desconexão.
        No caso, a partir do evento de escuta que criamos, o io.on(), dentro dela podemos definir outros eventos. Uma delas que iremos definir seria o disconnect.
            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });
            });
        Além do evento de desconexão que definimos acima, podemos definir outros eventos de escutas e emissões tbm.
        Por hora, podemos ver o evento em que o usuário conecta e desconecta do chat controlando isso pela path. Clicando no Entrar e em seguida apagando /chat da path.
        E como ele sabe disso? É muito simples, é porque a conexão estabelecida via socket, não existe mais!

    Aula 11 - Enviando mensagem de que usuário se conectou ao chat:
        Vamos simular uma conversa. No caso, para isso, seria necessário abrirmos três navegadore que são independentes de cada um.
        Para isso, podemos fazer o seguinte, abrir o navegador em que vc usa e os outros dois deixar como anônimo.
        Antes de realizarmos a conversa, precisamos tirar a conversa estática que temos na tela de chat.ejs.
        Para isso, pegamos o arquivo chat.ejs e faremos a seguinte modificação.
            <div class="col-md-10">
                <!-- <div class="dialogo">
                    <h4>Jorge</h4>
                    <p>Fala José, blz cara?</p>
                </div>
                
                <div class="dialogo">
                    <h4>José</h4>
                    <p>Opa, tudo certo!</p>
                </div>
                
                <div class="dialogo">
                    <h4>Jorge</h4>
                    <p>Vai estudar mais sobre NodeJS hoje?</p>
                </div>
                
                <div class="dialogo">
                    <h4>José</h4>
                    <p>Sim, com certeza. Vamos trabalhar com Websockets hoje, o assunto é bem interessante</p>
                </div>
                
                <div class="dialogo">
                    <h4>Jorge</h4>
                    <p>Show de bola, comunicação bi-direcional em páginas ou sistemas web é muito bacana mesmo</p>
                </div> -->
            </div>
        Acima, vamos apagar as conversas estáticas.
        Agora, a primeira coisa que iremos fazer, antes de estabelecer alguma conversa seria avisar que um outro usuário se conectou.
        No caso, no formato atual isso não é possível mesmo que via console consigamos ver que quando vc se conecta via o navegador seu e simulamos a outra conexão com outro navegador anônimo, via terminal conseguimos ver que ambos se conectaram, mas isso não fica explícito.
        Para isso, precisamos entender mais à fundo sobre o on e o emit.
        https://socket.io/pt-br/docs/v3/emitting-events/
        https://socket.io/docs/v4/listening-to-events/
        No caso, no arquivo chat.js do controllers precisamos colocar esse evento emit.
            module.exports.iniciaChat = function(application, req, res) {
                var dadosForm = req.body;

                // console.log(dadosForm);
                req.assert('apelido', 'Nome ou apelido é obrigatório!').notEmpty();
                req.assert('apelido', 'Nome ou apelido deve conter entre 3 à 15 caracteres!').len(3,15);

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao: erros});
                    // res.send('Existem erros no formulário!');
                    return;
                }

                emit('msgParaCliente');

                res.render('chat');
            }
        Agora, no chat.ejs, do script que criamos a variável socket, precisamos escutar esse emit que criamos.
            <script>
                var socket = io('http://localhost');

                socket.on('msgParaCliente', function(){
                    alert('Recebi uma requisição do servidor e estou tomando uma ação!');
                });
            </script>
        Além disso, para o emit que foi criado no chat.js do controllers, precisamos deixar claro que esse evento está sendo feito via o io que foi definido no app.js.
        Para isso, no app.js, vamos criar uma forma de estabelecer essa comunicação com o chat.js do controllers. Usaremo o set para isso.
        Obs: muito cuidado ao usar o set, pois dentro dela não se pode definir uma variável pré definida.
            var io = require('socket.io').listen(server);

            app.set('io', io);

            // Criar conexão por websocket.

            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });
            });
        Daí, no chat.js, vamos finalmente definir direito o evento emit recebendo a variável io definida no app.js.
            application.get('io').emit(
                'msgParaCliente',
                'Teste'
            );
        Note que, no evento que colocamos acima, podemos tbm definir uma msg que irá ser enviado. Assim, na função de callback que foi definido no socket.on do chat.ejs, lá podemos colocar a variável data.
            <script>
                var socket = io('http://localhost');

                socket.on('msgParaCliente', function(data){
                    alert(data);
                });
            </script>
        Com a forma acima, podemos realizar o teste.
        Agora, vamos implementar, de fato, o aviso de que uma pessoa se conectou.
            application.get('io').emit(
                'msgParaCliente',
                {apelido: dadosForm.apelido, mensagem: 'Aabou de entrar no chat.'}
            );
        Além disso, no chat.ejs vamos concatenar a msg que foi feito acima.
            <div class="col-md-10" id="dialogos">
					
			</div>
        E, usando a função append que temos no jquery, podemos colocar o seguinte:
            <script>
                var socket = io('http://localhost');

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });
            </script>
        Assim, o formato acima nos permite receber diretamente no chat o aviso da entrada do usuário.

    Aula 12 - Trocando mensagens entre usuários conectados no chat:
        Nessa aula, vamos aprender a realizar uma troca de msg real.
        No caso, vamos realizar modificações no chat.ejs. Assim, na tag nav, vamos realizar a seguinte modificação:
            <nav class="navbar navbar-default navbar-fixed-bottom" role="navigation">
                <div class="container">
                    <div class="panel-body campo-mensagem">
                        <div class="col-md-12">
                            <div class="input-group">
                                <input type="text" class="form-control" placeholder="Mensagem" id="mensagem">
                                <span class="input-group-btn">
                                    <button class="btn btn-default" type="button" id="enviar_mensagem">></button>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
            </nav>
        Além disso, no mesmo arquivo chat.ejs da views, vamos realizar as seguintes modificações na tag script:
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {apelido: '', mensagem: $('#mensagem').val()}
                    );
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });
            </script>
        Ou seja, utilizando o jquery.js, configuramos o evento de click nela, $('#enviar_mensage'), e dentro dela configuramos o evento emit.
        Agora, falta configurarmos isso no app.js, que seria configurar o envento de escutar o click:
            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });

                socket.on('msgParaServidor', function(data){
                    socket.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );
                });
            });
        No caso, ao realizarmos o teste, conseguimos enviar a mensagem no chat. Porém, no formato como está acima, só conseguimos enviar a msg para o chat diretamente para si mesmo.
        Ou seja, o outro usuáro online não consegue verificar a msg que vc publicou no chat.
        Para possibilitar que o outro usuário consiga visualizar a msg precisaria realizar a seguinte modificação no app.js usando um recurso chamado broadcast.
            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });

                socket.on('msgParaServidor', function(data){
                    socket.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );

                    socket.broadcast.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );
                });
            });
        Com isso, a troca de msg será possível, mas, note que, por hora só conseguimos trocar as msgs sem saber quem é que está se comunicando.
        No caso, só bastaria colocar o apelido. No caso, lembra que no chat.js do controllers, foi colocado um o dadosForm.apelido. Iremos chamar isso para o campo que configuramos no chat.ejs.
        Primeira coisa que precisamos realizar, seria definir a variável dadosForm de forma que dê para utilizar isso no chat.ejs, para a definição vamos realizar no chat.js do controllers no res.render('chat'):
            module.exports.iniciaChat = function(application, req, res) {
                var dadosForm = req.body;

                // console.log(dadosForm);
                req.assert('apelido', 'Nome ou apelido é obrigatório!').notEmpty();
                req.assert('apelido', 'Nome ou apelido deve conter entre 3 à 15 caracteres!').len(3,15);

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao: erros});
                    // res.send('Existem erros no formulário!');
                    return;
                }

                application.get('io').emit(
                    'msgParaCliente',
                    {apelido: dadosForm.apelido, mensagem: 'Acabou de entrar no chat.'}
                );

                res.render('chat', {dadosForm: dadosForm});
            }
        No caso, no chat.ejs, na tag nav vamos configurar mais um input da seguinte forma:
            <nav class="navbar navbar-default navbar-fixed-bottom" role="navigation">
                <div class="container">
                    <div class="panel-body campo-mensagem">
                        <div class="col-md-12">
                            <div class="input-group">
                                <input type="text" class="form-control" placeholder="Mensagem" id="mensagem">
                                <input type="hidden" vallue="<%=dadosForm.apelido%>" id="apelido">
                                <span class="input-group-btn">
                                    <button class="btn btn-default" type="button" id="enviar_mensagem">></button>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
            </nav>
        Em seguida, precisamos configurar isso no script que definimos no chat.ejs como o seguinte:
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {apelido: $('#apelido').val(), mensagem: $('#mensagem').val()}
                    );
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });
            </script>
        Voltando na aplicação, agora conseguiremos trocar as msgs com os apelidos incluídos.

    Aula 13 - Atualizando a relação de participantes da conversa:
        Agora, estamos praticamente fechando. Agora, só resta atualizr a relação dos participantes no chat.
        Ao entrarmos na tela do chat temos, na barra de menu, a opção participantes, onde nela mostra os participantes.
        Por hora ela estará estático. O objetivo agora é dinamizar isso mostrando quem está ou não participando no chat.
        No caso, no chat.ejs no views, localizamos essa parte e apagamos:
            <div class="row participantes" id="participantes" style="display:none">
				<div class="col-md-1"></div>
				<div class="col-md-10" id="pessoas">
					
				</div>
				<div class="col-md-1"></div>
                
            </div>
        Agora, no app.js, precisamos definir o evento emit que atualiza os participantes:
            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });

                socket.on('msgParaServidor', function(data){
                    // Dialogos
                    socket.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );

                    socket.broadcast.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );

                    // Participantes
                    socket.emit(
                        'participantesParaCliente',
                        {apelido: data.apelido}
                    );

                    socket.broadcast.emit(
                        'participantesParaCliente',
                        {apelido: data.apelido}
                    );
                });
            });
        Agora, usando, novamente, o jquery, vamos definir as funções no script do chat.ejs:
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {apelido: $('#apelido').val(), mensagem: $('#mensagem').val()}
                    );
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });

                socket.on('participantesParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<span class="participante">';
                        html += data.apelido;
                    html += '</span>';

                    $('#pessoas').append(html);
                });
            </script>
        Daí, agora conseguimos ver que os participantes estão atualizados.
        Entretanto, com um problema. Sempre ocorrer trocas de mensagens, isso fará aparecer mais e mais participantes, os mesmos, no caso.
        Isso deixará muito bagunçado, pois não saberemos quem está ou não participando exatamente.
        O usual, no caso, seria usar um banco de dados que guarde tais condições para podermos controlar se a pessoa está ou não participando.
        Mas no escopo do que temos, podemos improvisar isso usando mais um input hidden no chat.ejs.
            <nav class="navbar navbar-default navbar-fixed-bottom" role="navigation">
                <div class="container">
                    <div class="panel-body campo-mensagem">
                        <div class="col-md-12">
                            <div class="input-group">
                                <input type="text" class="form-control" placeholder="Mensagem" id="mensagem">
                                <input type="hidden" value="<%=dadosForm.apelido%>" id="apelido">
                                <input type="hidden" value="0" id="apelido_atualizado_nos_clientes">
                                <span class="input-group-btn">
                                    <button class="btn btn-default" type="button" id="enviar_mensagem">></button>
                                </span>
                            </div>
                        </div>
                    </div>
                </div>
            </nav>
        Em seguida, no script do chat.ejs, vamos chamar o uso disso:
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {
                            apelido: $('#apelido').val(),
                            mensagem: $('#mensagem').val(),
                            apelido_atualizado_nos_clientes: $('#apelido_atualizado_nos_clientes').val()
                        }
                    );
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });

                socket.on('participantesParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<span class="participante">';
                        html += data.apelido;
                    html += '</span>';

                    $('#pessoas').append(html);
                });
            </script>
        E no lado do servidor, app.js da raiz, vamos precisar definir as condicionais para participantes, pois, agora, a variável data a função que definimos recebe o valor 0 que definimos no chat.ejs.
            io.on('connection', function(socket){
                console.log('Usuário conectou!');

                socket.on('disconnect', function(){
                    console.log('Usuário desconectou!');
                });

                socket.on('msgParaServidor', function(data){
                    // Dialogos
                    socket.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );

                    socket.broadcast.emit(
                        'msgParaCliente',
                        {apelido: data.apelido, mensagem: data.mensagem}
                    );

                    // Participantes
                    if(parseInt(data.apelido_atualizado_nos_clientes) == 0) {
                        socket.emit(
                            'participantesParaCliente',
                            {apelido: data.apelido}
                        );
                
                        socket.broadcast.emit(
                            'participantesParaCliente',
                            {apelido: data.apelido}
                        );
                    }
                });
            });
        E, por fim, em chat.ejs, precisamos analisar se está sendo verificado esse valor 0 definido e alterar ela para 1.
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {
                            apelido: $('#apelido').val(),
                            mensagem: $('#mensagem').val(),
                            apelido_atualizado_nos_clientes: $('#apelido_atualizado_nos_clientes').val()
                        }
                    );

                    $('#apelido_atualizado_nos_clientes').val(1);
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);
                });

                socket.on('participantesParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<span class="participante">';
                        html += data.apelido;
                    html += '</span>';

                    $('#pessoas').append(html);
                });
            </script>   
        Basicamente, a lógica seria o seguinte, ao clicar em enviar a msg, pelo chat.ejs, esse evento dispara para o servidor, app.js da raiz, verificar se o participante está aparecendo pela primeira vez ou não pelo valor 0 e, em seguida, visto a entrada do participante, no chat.ejs, no mesmo evento em que ocorreu o click, ele modifica o valor 0 para 1 para indicar que esse participante está participando, evitando assim o problema de toda hora quando estiver enviando uma msg ficar aparecendo o mesmo participando toda hora ao ponto de correr o risco de confudir quem de fato está ou não participando na conversa.
        Só falta, agora, por preciosismo, colocar a imagem do participante, deixar vazio a aba onde digita a msg sempre que ocorrer o envio e sempre o scroll estar mostrando a ultima msg enviada usando o window.scrollTo(0, document.body.scrollHeight).
            <script>
                var socket = io('http://localhost');

                $('#enviar_mensagem').click(function(){
                    socket.emit(
                        'msgParaServidor',
                        {
                            apelido: $('#apelido').val(),
                            mensagem: $('#mensagem').val(),
                            apelido_atualizado_nos_clientes: $('#apelido_atualizado_nos_clientes').val()
                        }
                    );
                    
                    $('#mensagem').val('');
                    $('#apelido_atualizado_nos_clientes').val(1);
                });

                socket.on('msgParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<div class="dialogo">';
                        html += '<h4>' + data.apelido + '</h4>';
                        html += '<p>' + data.mensagem + '</p>';
                    html += '</div>';

                    $('#dialogos').append(html);

                    window.scrollTo(0, document.body.scrollHeight);
                });

                socket.on('participantesParaCliente', function(data){
                    // alert(data);
                    var html = ''
                    html += '<span class="participante">';
                        html+= '<img src="images/ico_usuario.png">';
                        html += data.apelido;
                    html += '</span>';

                    $('#pessoas').append(html);
                });
            </script>

    Aula 14 - Download dos arquivos do projeto:
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto Multiroom Chat completo.

        Bons estudos ;)

Seção 14 - MongoDB - Saindo do BD relacional para o BD orientado a documentos:
    Modo de uso do MongoDB: https://www.mongodb.com/docs/manual/introduction/
    Obs: O formato de uso do MongoDB tem uita similaridade com o Firebase, que é um outro banco de dados não relacional.
    Aula 1 - Introdução ao MongoDB:
        Para entender a utilidade boa do bando de dados Mongo Db, precisamos entender melhor a diferença entre bando de dados relacionais e não relacionais.
        Banco de dados:
            https://www.devmedia.com.br/conceitos-fundamentais-de-banco-de-dados/1649
            https://www.homehost.com.br/blog/tutoriais/mysql/o-que-e-um-banco-de-dados/

        Banco de dados relacionais:
            https://pt.wikipedia.org/wiki/Banco_de_dados_relacional
            https://www.devmedia.com.br/bancos-de-dados-relacionais/20401
            https://kondado.com.br/blog/blog/2022/09/05/entenda-o-que-e-um-banco-de-dados-relacional/

        Banco de dados não relacionais:
            https://learn.microsoft.com/pt-br/azure/architecture/data-guide/big-data/non-relational-data
            https://www.digitalhouse.com/br/blog/banco-de-dados-relacional-e-nao-relacional/
            https://kondado.com.br/blog/blog/2022/11/10/o-que-e-um-banco-de-dados-nao-relacional/

        Banco de dados relacional vs não relacional:
            https://natahouse.com/pt/bancos-relacionais-x-bancos-nao-relacionais-quando-usar-cada-um
            https://pt.stackoverflow.com/questions/191919/banco-de-dados-n%C3%A3o-relacionais-vs-banco-de-dados-relacionais#:~:text=Vantagens%20dos%20bancos%20Relacionais%3A,%C3%A9%20a%20estrutura%20menos%20flexivel.
            https://mundodevops.com/blog/bancos-nosql-vs-relacionais/

        Basta ler e entender!

        O Mongo DB, no caso, se encaixa dentro do banco de dados não relacionais!

    Aula 2 - Instalando o banco de dados MongoDB:
        Vamos instalar o banco de dados MongoDB.
        https://www.mongodb.com/home

        Como eu uso Linux, teria que acessar para a versão certa do Ubuntu:
            https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/
            https://www.cherryservers.com/blog/how-to-install-and-start-using-mongodb-on-ubuntu-20-04

        Instalado e iniciado acima, bastaria acessar a porta 27017.

        Os comandos para manipular o banco de dados:
             https://docs.mongodb.com/mongodb-shell/

    Aula 3 - Exibindo, criando e removendo bancos de dados:
        Vamos aprender a manipular um pouco sobre esse banco de dados.
        Comandos:
            - show dbs - Serve para verificar quais tipos de banco de dados temos dentro:
                test> show dbs
                admin   40.00 KiB
                config  60.00 KiB
                local   72.00 KiB
            - use - Serve para alternar entre banco de dados e tbm para criar uma.
                test> use curso_mongodb
                switched to db curso_mongodb

                O comando acima pede para alternar em um banco de dados que nem existe.
                Disso, será criado uma, mas quando damos o show dbs não será ainda exibido, pois seria necessário inserir algum conteúdo dentro dela.
            - db.alunos.insertOne( {Nome: 'Leonardo'} ) - Isso irá inserir um conteúdo dentro do banco de dados e depois podemos ver ao digitarmos show dbs depois que colocamos o conteúdo.
                curso_mongodb> db.alunos.insertOne( {Nome: 'Leonardo'} )
                {
                acknowledged: true,
                insertedId: ObjectId("639f98992b9848ba15849bff")
                }
                curso_mongodb> show dbs
                admin           40.00 KiB
                config         108.00 KiB
                curso_mongodb    8.00 KiB
                local           72.00 KiB
            - db.dropDatabase() - Serve para eliminar o banco de dados em que vc está conectado.
                curso_mongodb> db.dropDatabase()
                { ok: 1, dropped: 'curso_mongodb' }
                curso_mongodb> show dbs
                admin    40.00 KiB
                config  108.00 KiB
                local    72.00 KiB

    Aula 4 - Exibindo, criando e removendo coleções:
        Vamos aprender a criar e manipular as coleções dentro do banco de dados.
        Comandos:
            - use (nome do banco de dados)
            - db.createCollection("colocar o nome da coleção") - Permite criar uma coleção dentro do banco de dados que vc criou.
                curso_mongodb> use curso_mongodb
                already on db curso_mongodb
                curso_mongodb> db.createCollection("alunos")
                { ok: 1 }
            - db.getCollectionNames() - permite exibit quais coleções esse banco de dados possui.
                curso_mongodb> db.getCollectionNames()
                [ 'alunos' ]
                curso_mongodb> 
                (To exit, press Ctrl+C again or Ctrl+D or type .exit)
                curso_mongodb> db.createCollection("cursos")
                { ok: 1 }
                curso_mongodb> db.getCollectionNames()
                [ 'alunos', 'cursos' ]
            - db.nome da coleção.drop() - Serve para remover a coleção que vc criou dentro do banco de dados.
                curso_mongodb> db.cursos.drop()
                true
                curso_mongodb> db.getCollectionNames()
                [ 'alunos' ]

    Aula 5 - Inserindo documentos:
        Vamos agora aprender a inserir documentos dentro do banco de dados.
        Um pouco de conceitos sobre inserção de documentos dentro do banco de dados MongoDB:
            https://4linux.com.br/o-que-e-mongodb/
            https://www.alura.com.br/artigos/mongodb-o-banco-baseado-em-documentos
            https://felipetoscano.com.br/inserir-documento-no-mongodb/
            http://db4beginners.com/blog/incluir-e-excluir-dados-mongodb/
        Comandos:
            - Seguir o artigo - https://felipetoscano.com.br/inserir-documento-no-mongodb/

    Aula 6 - Consultando documentos com operadores de comparação:
        Vamos aprender a consultar os documentos.
        https://www.mongodb.com/docs/manual/reference/method/js-collection/

    Aula 7 - Consultando documentos com operadores lógicos:
        Basta estudar por aqui:
            https://www.mongodb.com/docs/manual/reference/operator/query-logical/

    Aula 8 - Atualizando documentos:
        Bastar estudar por aqui:
            https://www.mongodb.com/docs/manual/tutorial/update-documents/

    Aula 9 - Removendo documentos:
        Basta estudar por aqui:
            https://www.mongodb.com/docs/mongodb-shell/crud/delete/

    Aula 10 - Extra - Como mapear um path no Windows:
        No caso do Linux Ubuntu bastaria configurar por mongosh.
        O fato de eu puder estar digitando o comando sudo systemctl start mongod já é um indicativo de que foi mapeado.

    Aula 11 - Extra - Interface gráfica nativa do MongoDB (Informações administrativas):
        Procurar em como rodar o mongod --rest na versão Ubuntu, pois isso parece que tem para windows.
        Basta seguir esse link:
            https://www.cherryservers.com/blog/how-to-install-and-start-using-mongodb-on-ubuntu-20-04
            https://www.w3resource.com/mongodb/connections.php
            https://www.mongodb.com/docs/v4.2/tutorial/install-mongodb-on-ubuntu/#run-mongodb-community-edition

    Aula 12 - Atividades para fixação do conteúdo:
        Atividades para fixação do conteúdo

        1) Crie um banco de dados chamado biblioteca


        2) Crie uma coleção (collection) chamada livros


        3) Crie os seguintes documentos:

        título: Introdução a linguagem de marcação HTML
        valor: 25.00
        Autor: João

        --

        título: NodeJS do básico ao avançado
        valor: 280.00
        Autor: Jorge

        --

        título: Android - criando apps reais
        valor: 290.00
        Autor: Jamilton

        --

        título: PHP e MySQL
        valor: 190.00
        Autor: Fernando

        --

        título: Lógica de Programação
        valor: 20.00
        Autor: Maria



        4) Crie as seguintes consultas:

        Crie uma consulta que retorne apenas os documentos de livros com valores superiores a 200.00

        Crie uma consulta que retorne apenas os documentos com valores entre 10 e 30

        Crie uma consulta que retorne todos os documentos, executo aqueles cujo autor seja Fernando



        5) Atualize os seguintes documentos:

        Atualize o documento cujo o título é PHP e MySQL, passando seu valor de 190.00 para 175.00

        Atualize o documento cujo autor é Jorge, passando seu título para Curso Completo de NodeJS

        Atualize todos os documentos cujo valor são iguais ou inferiores a 25.00 para o valor 27.00



        6) Remove os seguintes documentos:

        Remova o documento cujo autor é João

        Remova todos os documentos cujo valor é superior a 280.00

        Remova todos os documentos cujo valor é inferior a 30.00

Seção 15 - Projeto prático - MMORPG baseado na séria de TV Game Of Thrones:
    Aula 1 - Download de arquivos estáticos (assets) e HTML:
        Download de arquivos estáticos (assets) e HTML
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos HTMLs e assets do projeto MMORPG Game Of Thrones.

        Bons estudos ;)

    Aula 2 - Ajustando routes e views:
        Com o arquivo da aula anterior baixado, vamos configuar o ambiente de modo estático do nosso novo projeto.
        - Criar um diretório com o nome do nosso novo projeto, mmorpg_got, no caso, dentro do arquivo baixado, na aula anterior, mmorpg_got_arquivos_do_projeto, dentro dela existem duas pastas, htmls_e_assets e servidor_nodejs_pre_configurado. Vc irá mudar o nome do diretório servidor_nodejs_pre_configurado para o mmorpg_got.
        - Vamos verificar primeiro se está tudo funcionando corretamente. No caso, colocando vc como usuário root do projeto novo, basta rodar o comando nodemon app. Se estiver tudo funcionando deverá aparecer a msg "Bem vindo a sua app NodeJS!", que é justamente o que temos no index.js do routes.
        - Agora, na pasta htmls_e_assets iremos mandar as configurações estáticas para o nosso novo projeto.
            - Primeiro, todos os arquivos htmls dessa pasta iremos enviar na pasta views.
            - Segundo, na pasta public do nosso projeto dentro dela haverá três pastas css, images e js. Dentro dela iremos os mesmos conteúdos das respectivas mesmas pastas que se encontram no htmls_e_assets.
        - Agora, vamos configurar as rotas, no caso, vincularemos os htmls que enviamos para possibilitar a sua exibição pelo index.js. Lembrando que como estamos usando o ejs, então todos os htmls que temos precisamos mudar a sua extensão para ejs.
            module.exports = function(application){
                application.get('/', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    res.render('index');
                });
            }
        - Faremos a mesma coisa para outros arquivos ejs que temos. No caso, dentro de routes iremos criar mais arquivos de extensão js, cadastro.js e jogo.js.
            module.exports = function(application){
                application.get('/cadastro', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    res.render('cadastro');
                });
            }
            E
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    res.render('jogo');
                });
            }

    Aula 3 - Ajustando routes e controllers:
        Nessa aula vamos fazer com que as nossas rotas executem os nossos controllers, como de costume e de boas práticas!
        No caso, no diretório controllers, iremos criar os respectivos arquivos que correspondem aos arquivos que estão no routes.
        - cadastro.js
        - index.js
        - jogo.js
        No arquivo, cadastro.js do controllers, vamos colocar o seguinte
            module.exports.cadastro = function(application, req, res){
                res.render('cadastro');
            }
        Em seguida, advinha só, no cadastro.js de routes vamos aplicar a função módulo definido no cadastro.js do controllers
            module.exports = function(application){
                application.get('/cadastro', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('cadastro');
                    application.app.controllers.cadastro.cadastro(application, req, res);
                });
            }
        Obs: Uma outra coisa que precisaria realizar seria carregar tais módulos pelo server.js usando o consign. Mas isso já está configurado.
            /* efetua o autoload das rotas, dos models e dos controllers para o objeto app */
            consign()
                .include('app/routes')
                .then('app/models')
                .then('app/controllers')
                .into(app);
        Agora, analogamente à anterior, no index.js do controllers, vamos realizar o mesmo processo.
            module.exports.index = function(application, req, res) {
                res.render('index');
            }
        Enquanto que no index.js do routes precisamos realizar o seguinte:
            module.exports = function(application){
                application.get('/', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('index');
                    application.app.controllers.index.index(application, req, res);
                });
            }
        Analogamente, realizamos o mesmo processo para jogos.js do controllers e routes, respectivamente.
            module.exports.jogo = function(application, req, res) {
                res.render('jogo');
            }
            E
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('jogo');
                    application.app.controllers.jogo.jogo(application, req, res);
                });
            }

    Aula 4 - Tela de cadastro de usuários - recebendo e validando dados:
        Vamos corrigir alguns dados errados que estão presentes no cadastro.ejs e cadastro.js do controllers.
            <div class="container">
	    		
                <form class="form-cadastro" action="/cadastrar" method="post">
                
                    <div class="row">
                        <div class="col-xs-4">
                            <div class="form-group">
                                <label for="nome" class="col-sm-2 col-form-label">Nome</label>
                                <input type="nome" class="form-control" id="nome" name="nome" placeholder="Nome">
                            </div>
                        </div>
                        
                        <div class="col-xs-4">
                            <div class="form-group">
                                <label for="usuario" class="col-sm-2 col-form-label">Usuário</label>
                                <input type="usuario" class="form-control" id="usuario" name="usuario" placeholder="Usuário">
                            </div>
                        </div>
                        
                        <div class="col-xs-4">
                            <div class="form-group">
                                <label for="senha" class="col-sm-2 col-form-label">Senha</label>
                                <input type="password" class="form-control" id="senha" name="senha" placeholder="Password">
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group row">
                    
                        <div class="col-xs-2">
                            <img src="images/casa_arryn.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="arryn"> Casa Arryn
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_baratheon.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="baratheon"> Casa Baratheon
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_greyjoy.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="greyjoy"> Casa Greyjoy
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_lannister.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="lannister"> Casa Lannister
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_martell.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="martell"> Casa Martell
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_stark.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="stark"> Casa Stark
                            </center>
                        </div>
                    </div>
                    
                    <div class="form-group row">
                    
                        <div class="col-xs-3"></div>
                    
                        <div class="col-xs-2">
                            <img src="images/casa_targaryen.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="targaryen"> Casa Targaryen
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_tully.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="tully"> Casa Tully
                            </center>
                        </div>
                        
                        <div class="col-xs-2">
                            <img src="images/casa_tyrell.jpg" class="img-responsive img-radio">
                            <center>
                                <input type="radio" id="left-item" name="casa" value="tyrell"> Casa Tyrell
                            </center>
                        </div>
                        
                        <div class="col-xs-3"></div>
                    </div>		
                    
                
                    <div class="form-group row">
                        <button type="submit" class="btn btn-primary">Confirmar cadastro</button>
                    </div>
                    

                </form>
                        
            </div>
            Agora, no cadastro.js de routes vamos precisar configurar a aba cadastrar para receber a submissão.
                module.exports = function(application){
                    application.get('/cadastro', function(req, res){
                        // res.send('Bem vindo a sua app NodeJS!');
                        // res.render('cadastro');
                        application.app.controllers.cadastro.cadastro(application, req, res);
                    });

                    application.post('/cadastrar', function(req, res){
                        // res.send('Bem vindo a sua app NodeJS!');
                        // res.render('cadastro');
                        application.app.controllers.cadastro.cadastrar(application, req, res);
                    });
                }
            Agora, no cadastro.js do controllers vamos precisar definir a função para isso.
                module.exports.cadastro = function(application, req, res){
                    res.render('cadastro');
                }

                module.exports.cadastrar = function(application, req, res) {
                    res.send('Teste - vamos cadastrar!');
                }
            Podemos testar isso agora no localhost/cadastro colocando os nomes, usuário e senha.
            Se apareceu a mensagem "Teste - vamos cadastrar!", significa que está funcionando corretamente.
            Agora, vamos precisar recuperar tais dados preechidos no cadastro.js do controllers.
                module.exports.cadastro = function(application, req, res){
                    res.render('cadastro');
                }

                module.exports.cadastrar = function(application, req, res) {
                    // res.send('Teste - vamos cadastrar!');
                    var dadosForm = req.body;
                    req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                    req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                    req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                    req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                    var erros = req.validationErrors();

                    if(erros) {
                        res.send('Existem erros no formulário!');
                        return;
                    }

                    res.send('Podemos cadastrar!');
                }
            Podemos, novamente, realizar os testes e visto que está funcionando, vamos mehorar a forma como está sendo enviado a msg de erro.
                module.exports.cadastro = function(application, req, res){
                    res.render('cadastro', {validacao: {}});
                }

                module.exports.cadastrar = function(application, req, res) {
                    // res.send('Teste - vamos cadastrar!');
                    var dadosForm = req.body;
                    req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                    req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                    req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                    req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                    var erros = req.validationErrors();

                    if(erros) {
                        // res.send('Existem erros no formulário!');
                        res.render('cadastro', {validacao: erros});
                        return;
                    }

                    res.send('Podemos cadastrar!');
                }
            Agora, no cadastro.ejs do views precisamos configurar uma div que mostre tais erros para o usuário
                <div class="container">

                    <% if(validacao.length > 0) { %> 
                        <div class="alert alert-danger">
                            <strong>Atenção!</strong>
                            <ul>
                                <% for(var i = 0; i < validacao.length; i++) { %>
                                    <li><%=validacao[i].msg%></li>
                                <% } %>
                            </ul>
                        </div>
                    <% } %>
            Feito isso, agora, ele estará sendo exibido ao usuário essa msg de erro.
            Agora, para melhorar a usabilidade do usuário de não ter que ficar preenchendo novamente as msgs sempre que der algum erro, vamos configurar uma forma que tais msgs permaneçam
            No caso, no cadastro.js de controllers, vamos colocar o dadosForm dentro da msg de erros.
                module.exports.cadastro = function(application, req, res){
                    res.render('cadastro', {validacao: {}, dadosForm: {}});
                }

                module.exports.cadastrar = function(application, req, res) {
                    // res.send('Teste - vamos cadastrar!');
                    var dadosForm = req.body;
                    req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                    req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                    req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                    req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                    var erros = req.validationErrors();

                    if(erros) {
                        // res.send('Existem erros no formulário!');
                        res.render('cadastro', {validacao: erros, dadosForm: dadosForm});
                        return;
                    }

                    res.send('Podemos cadastrar!');
                }
            Agora, falta configurar isso no cadastro.ejs com values.
                <div class="row">
					<div class="col-xs-4">
						<div class="form-group">
							<label for="nome" class="col-sm-2 col-form-label">Nome</label>
							<input type="nome" value="<%=dadosForm.nome%>" class="form-control" id="nome" name="nome" placeholder="Nome">
						</div>
					</div>
					
					<div class="col-xs-4">
						<div class="form-group">
							<label for="usuario" class="col-sm-2 col-form-label">Usuário</label>
							<input type="usuario" value="<%=dadosForm.usuario%>" class="form-control" id="usuario" name="usuario" placeholder="Usuário">
						</div>
					</div>
					
					<div class="col-xs-4">
						<div class="form-group">
							<label for="senha" class="col-sm-2 col-form-label">Senha</label>
							<input type="password" value="<%=dadosForm.senha%>" class="form-control" id="senha" name="senha" placeholder="Password">
						</div>
					</div>
				</div>
            Assim, sempre que o usuário errar o preenchimento de alguns dados ele não terá o trabalho de ter que preencher novamente.

    Aula 5 - NPM - Instalando o módulo de conexão com o MongoDB:
        Vamos estabelecer a conexão com o MongoDB.
        No caso, no diretório projeto aberto pelo terminal digite:
            npm install mongodb --save

    Aula 6 - NodeJS e MongoDB - Configurando a conexão com o banco de dados:
        Vamos criar um novo arquivo, dbConnection.js dentro do config, que é o módulo que irá servir de configuração de conexão com o banco de dados e dentro dela colocar
            // Importar o mongodb
            var mongo = require('mongodb');

            module.exports = function(){
                console.log('Entrou na função de conexão');
                var db = new mongo.Db(
                    'got',
                    new mongo.Server(
                        'localhost', // String contendo o endereço onde está o banco de dados
                        27017, // porta de conexão
                        {}
                    ),
                    {}
                );

                return db;

            }

        Após isso, no arquivo server.js do config, vamos precisar usar o consign para chamar essa configuração.
            consign()
                .include('app/routes')
                .then('config/dbConnection.js')
                .then('app/models')
                .then('app/controllers')
                .into(app);

        Porém, tais configurações acima resultaram nesse tipo de problema
            TypeError: mongo.Server is not a constructor
                at module.exports (/home/leonardo/Documentos/estudos/mmorpg_got/config/dbConnection.js:7:9)
                at Consign.into (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/consign/lib/consign.js:240:17)
                at Object.<anonymous> (/home/leonardo/Documentos/estudos/mmorpg_got/config/server.js:35:3)
                at Module._compile (node:internal/modules/cjs/loader:1159:14)
                at Module._extensions..js (node:internal/modules/cjs/loader:1213:10)
                at Module.load (node:internal/modules/cjs/loader:1037:32)
                at Module._load (node:internal/modules/cjs/loader:878:12)
                at Module.require (node:internal/modules/cjs/loader:1061:19)
                at require (node:internal/modules/cjs/helpers:103:18)
                at Object.<anonymous> (/home/leonardo/Documentos/estudos/mmorpg_got/app.js:2:11)
                at Module._compile (node:internal/modules/cjs/loader:1159:14)
                at Module._extensions..js (node:internal/modules/cjs/loader:1213:10)
                at Module.load (node:internal/modules/cjs/loader:1037:32)
                at Module._load (node:internal/modules/cjs/loader:878:12)
                at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)
                at node:internal/main/run_main_module:23:47

            Node.js v18.12.1
            [nodemon] app crashed - waiting for file changes before starting...
        
        O que significa que não estamos conseguindo configurar a conexão com o banco de dados MongoDB.

        Para isso irei assitir um curso de MongoDB, Curso Completo MongoDB 2022 [NoSQL do Básico ao Avançado!], cujo o professor usa tbm o sistema operacional Linux para conseguir estabelecer as configurações com o banco de dados.
        Lugar para tirar um certiicação bem forte para MongoDB: https://www.mongodb.com/community/forums/c/university/19

            A melhor maneira de instalar o MongoDB no linux é seguir o download oficial:

            https://www.mongodb.com/try/download/community



            Basta selecionar seu sistema operacional e fazer o download do software community edition que é a verão que utilizaremos, é grátis e open source!



            Caso esteja no Ubuntu e prefira gerenciar sua instalação com seu package manager (APT), siga os seguintes passos:

            https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/#official-mongodb-packages



            Tenha em mente que o pacote que já existe no apt-get não é oficial do mongo db, e isso está confirmado no link acima. Basta adicionar o PPA oficial para poder instalar com o APT.
        
        O link onde o mongosh, via mongod, bate
            mongodb://127.0.0.1:27017/?directConnection=true serverSelectionTimeoutMS=2000 appName=mongodb+1.6.1
        
        Precisa se instalar, via sudo apt-get, os usos de mongo e mongod. Bastaria jogar no terminal mongo e mongod, para verificas quais comandos precisaria fazer para instalar cada uma.

        Caso o sudo systemctl start mongod não estiver funcionando:
            https://stackoverflow.com/questions/60309575/mongodb-service-failed-with-result-exit-code

        A construção que funcionou em conectar ao mongoDB community Edition, onde está rodando o mongod, pelo comando sudo systemctl start mongod, seria o seguinte:
            const { MongoClient } = require("mongodb");

            // Connection URI
            const uri =
            "mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1";

            // Create a new MongoClient
            const client = new MongoClient(uri);

            async function run() {
            try {
                // Connect the client to the server (optional starting in v4.7)
                await client.connect();

                // Establish and verify connection
                await client.db("admin").command({ ping: 1 });
                console.log("Entrou na função de conexão");
            } finally {
                // Ensures that the client will close when you finish/error
                await client.close();
            }
            }
            run().catch(console.dir);
        Donde, o ponto curioso seria o local const uri, onde tem a string "mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1";.
        Essa string, conseguimos obter, depois que seguir a instalação tudo certinho nesse link https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/, vc consegue rodar o comando "mongosh" pelo terminal e será exibido o algo parecido com o seguinte:
            Current Mongosh Log ID:	63a8e2809212410c1b4a1d9b
            Connecting to:		mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1
            Using MongoDB:		6.0.3
            Using Mongosh:		1.6.1

            For mongosh info see: https://docs.mongodb.com/mongodb-shell/

            ------
            The server generated these startup warnings when booting
            2022-12-25T20:39:33.098-03:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem
            2022-12-25T20:39:33.255-03:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted
            2022-12-25T20:39:33.255-03:00: vm.max_map_count is too low
            ------

            ------
            Enable MongoDB's free cloud-based monitoring service, which will then receive and display
            metrics about your deployment (disk utilization, CPU, operation statistics, etc).
            
            The monitoring data will be available on a MongoDB website with a unique URL accessible to you
            and anyone you share the URL with. MongoDB may use this information to make product
            improvements and to suggest MongoDB products and deployment options to you.
            
            To enable free monitoring, run the following command: db.enableFreeMonitoring()
            To permanently disable this reminder, run the following command: db.disableFreeMonitoring()
            ------

            Warning: Found ~/.mongorc.js, but not ~/.mongoshrc.js. ~/.mongorc.js will not be loaded.
            You may want to copy or rename ~/.mongorc.js to ~/.mongoshrc.js.
            test>

        Onde, onde está escrito Connecting to, mostra exatamente o uri na qual vc deverá colocar.
        Agora, vamos precisar configurar o server.js, da mesma forma como foi expressa anteriormente e, por fim, quando rodarmos "nodemon app" aparecerá o seguinte estatus
            [nodemon] restarting due to changes...
            [nodemon] starting `node app`
            consign v0.1.6 Initialized in /home/leonardo/Documentos/estudos/mmorpg_got
            + ./app/routes/cadastro.js
            + ./app/routes/index.js
            + ./app/routes/jogo.js
            + ./config/dbConnection.js
            ! Entity not found /home/leonardo/Documentos/estudos/mmorpg_got/app/models
            + ./app/controllers/cadastro.js
            + ./app/controllers/index.js
            + ./app/controllers/jogo.js
            Servidor online
            Entrou na função de conexão

        Agora, creio que podemos dar continuidade na aula.

        No caso, o formato atual, sempre que acessarmos o localhost irá estabelecer a conexão com o banco de dados mongoDB de forma desnecessária.
        Isso é ruim, pois no quesito financeiro pode ser custoso, pois estaria realizando uma requisição desnecessariamente.
        No caso, o ideal seria estabelecer a conexão com o banco de dados apenas quando for necessário por via da ação de um usuário que estiver mexendo no na tela.
        Para resolvermos esse problema realizamos o seguinte. (https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/)
            onst { MongoClient } = require("mongodb");

            // Connection URI
            const uri =
            "mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1";

            // Create a new MongoClient
            const client = new MongoClient(uri);

            var connMongoDB = function() {async function run() {
            try {
                // Connect the client to the server (optional starting in v4.7)
                await client.connect();

                // Establish and verify connection
                await client.db("admin").command({ ping: 1 });
                console.log("Entrou na função de conexão");
            } finally {
                // Ensures that the client will close when you finish/error
                await client.close();
            }
            }
            run().catch(console.dir);
            }

            module.exports = function() {
                return connMongoDB;
            }
        Ao olharmos na nossa aplicação, vamos ver que não aparecerá o console.log('Entrou na função de conexão').

    Aula 7 - Cadastrando usuários:
        Agora, vamos cadastrar o formulário no mongoDB.
        Para isso, vamos criar um diretório models dentro do diretório app e dentro dela criamos um arquivo UsuariosDAO.js.
        Dentro do arquivo UsuariosDAO.js colocamos o seguinte código para podermos eniar dados para o MongoDB.
        Como os nossos models estão sendo incorporados pelo consign, então precisamos fornecer a nossa classe no momento em que o autoloader carregar o nosso model. No caso, vamos colocar o module.exports no UsuarioDAO.js.
            function UsuariosDAO() {
                console.log('Objeto carregado');
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Além disso, no cadastro.js de controllers, vamos precisar chamar essa classe, UsuariosDAO, definido da seguinte forma
            module.exports.cadastro = function(application, req, res){
                res.render('cadastro', {validacao: {}, dadosForm: {}});
            }

            module.exports.cadastrar = function(application, req, res) {
                // res.send('Teste - vamos cadastrar!');
                var dadosForm = req.body;
                req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    // res.send('Existem erros no formulário!');
                    res.render('cadastro', {validacao: erros, dadosForm: dadosForm});
                    return;
                }

                var UsuariosDAO = new application.app.models.UsuariosDAO;

                res.send('Podemos cadastrar!');
            }
        
        Agora, podemos testar fazendo um cadastro manual. Assim, visto que está funcionando, agora, vamos ter que ir no arquivo UsuariosDAO.js e nela definir o prototype.
            function UsuariosDAO() {
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                console.log('Objeto carregado');
            }

            module.exports = function(){
                return UsuariosDAO;
            }

        Agora, no cadastro, na variável UsuariosDAO que foi criado vamos precisar acessar a propriedade inserirUsuario
            module.exports.cadastro = function(application, req, res){
                res.render('cadastro', {validacao: {}, dadosForm: {}});
            }

            module.exports.cadastrar = function(application, req, res) {
                // res.send('Teste - vamos cadastrar!');
                var dadosForm = req.body;
                req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    // res.send('Existem erros no formulário!');
                    res.render('cadastro', {validacao: erros, dadosForm: dadosForm});
                    return;
                }

                var UsuariosDAO = new application.app.models.UsuariosDAO;

                UsuariosDAO.inserirUsuario(dadosForm);

                res.send('Podemos cadastrar!');
            }
        Agora, novamente, vamos testar se desta vez está sendo enviado um objeto com todos os parâmetros estabelecidos.
        No nodemon, devera aparecer algo do segunite gênero
            [nodemon] restarting due to changes...
            [nodemon] starting `node app`
            consign v0.1.6 Initialized in /home/leonardo/Documentos/estudos/mmorpg_got
            + ./app/routes/cadastro.js
            + ./app/routes/index.js
            + ./app/routes/jogo.js
            + ./config/dbConnection.js
            + ./app/models/UsuariosDAO.js
            + ./app/controllers/cadastro.js
            + ./app/controllers/index.js
            + ./app/controllers/jogo.js
            Servidor online
            {
            nome: 'Leonardo',
            usuario: 'leolexus',
            senha: '123456',
            casa: 'targaryen'
            }
        Agora, falta abrirmos conexão com o MongoDB e inserir tais informações dentro do banco de dados.
        No caso, em cadastro.js do controllers, vamos precisar chamar a conexão com o banco de dados.
            module.exports.cadastro = function(application, req, res){
                res.render('cadastro', {validacao: {}, dadosForm: {}});
            }

            module.exports.cadastrar = function(application, req, res) {
                // res.send('Teste - vamos cadastrar!');
                var dadosForm = req.body;
                req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    // res.send('Existem erros no formulário!');
                    res.render('cadastro', {validacao: erros, dadosForm: dadosForm});
                    return;
                }

                var connection = application.config.dbConnection;
                console.log(connection);
                var UsuariosDAO = new application.app.models.UsuariosDAO(connection);

                UsuariosDAO.inserirUsuario(dadosForm);

                res.send('Podemos cadastrar!');
            }
        A forma acima deverá aparecer no nodemon a seguinte msg
            [nodemon] restarting due to changes...
            [nodemon] starting `node app`
            consign v0.1.6 Initialized in /home/leonardo/Documentos/estudos/mmorpg_got
            + ./app/routes/cadastro.js
            + ./app/routes/index.js
            + ./app/routes/jogo.js
            + ./config/dbConnection.js
            + ./app/models/UsuariosDAO.js
            + ./app/controllers/cadastro.js
            + ./app/controllers/index.js
            + ./app/controllers/jogo.js
            Servidor online
            [Function: connMongoDB]
        O ue indica que a conexão com o banco de dados foi estabelecida.
        Assim, no arquivo UsuarioDAO.js vamos chamar a tal conexão da seguinte forma
            function UsuariosDAO(connection) {
                this._connection = connection();
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // insert(usuario);
                this._connection.open(function(err, mongoclient){
                    mongoclient.collection('usuarios', function(err, collection){
                        collection.insert(usuario);
                    });
                });
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Agora, vamos testar se vamos conseguir inserir alguma informação no mongoDB.
        No caso, podemos executar o comando mongosh para verificarmos se estaria criando ou não.
        No caso, não estou conseguindo inserir. Voltar a assistir as aulas de mongoDB para verificar como no formato atualizado podemos inserir algum documento para conseguirmos dar continuidade no curso de nodejs.
        Uma solução para isso, bastaria ver essa documentação do github:
            https://github.com/mongodb/node-mongodb-native

        No caso, via a instrução acima, o que funcionou foi o seguinte código colocado de forma não assíncrona em dbConnection
            const { MongoClient } = require('mongodb');
            // or as an es module:
            // import { MongoClient } from 'mongodb'

            // Connection URL
            // const url = 'mongodb://localhost:27017';
            const url = 'mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1';
            const client = new MongoClient(url);

            // Database Name
            const dbName = 'got';

            var connMongoDB = function main() {
            // Use connect method to connect to the server
            client.connect();
            console.log('Conectado com sucesso no servidor!');
            const db = client.db(dbName);
            // const collection = db.collection('usuarios').insertOne({nome: 'Leonardo', apelido: 'OtakuFedido', senha: 741852, casa: 'Corvinal'});

            // the following code examples can be pasted here...

            // return 'done.';
            // return collection;
            return db;
            }

            // main()
            //   .then(console.log)
            //   .catch(console.error)
            //   .finally(() => client.close());

            module.exports = function() {
            return connMongoDB;
            }
        Precisa tbm aprender a fechar a conexão com o banco de dados:
            https://www.mongodb.com/community/forums/t/client-close-is-not-a-function/579
            https://www.mongodb.com/community/forums/t/mongoclient-nodejs-open-close-connection-events/15042
            https://stackoverflow.com/questions/8373905/when-to-close-mongodb-database-connection-in-nodejs
            https://github.com/mongodb/node-mongodb-native

    Aula 8 - Opcional - Download dos arquivos MMORPG GOT:
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto MMORPG GOT no estado em que se encontram na aula anterior.

        Bons estudos ;)

Seção 16 - Autenticação através de sessão com Express-Session:
    Aula 1 - Sessão com Express-Session:
        Vamos aprender sobre o conceito de Express-Session.
        https://stackoverflow.com/questions/23566555/whats-difference-with-express-session-and-cookie-session
        https://expressjs.com/pt-br/advanced/best-practice-security.html#:~:text=O%20middleware%20express%2Dsession%20armazena,para%20um%20ambiente%20de%20produ%C3%A7%C3%A3o.

    Aula 2 - NPM - Instalando o Express-Session:
        Vamos instalar o express-session. Para isso, bastaria rodar o seguinte comando de linha:
            npm install express-session --save

    Aula 3 - Criando o controller de autenticação:
        Vamos aprender a criar controller de autenticação.
        No caso, no arquivo index.ejs de views, vamos realizar a seguinte modificação na div com class container.
            <nav class="navbar navbar-default navbar-static-top">
                <div class="container">
                    <form class="form-inline form-entrar" action="/autenticar" method="post">
                        <div class="form-group">				
                            <input type="text" name="usuario" id="usuario" placeholder="Usuário" class="form-control" autocomplete="off" />
                            <input type="password" name="senha" id="senha" placeholder="Senha" class="form-control" />
                            <button type="submit" class="btn btn-success">Entrar</button>
                            <button type="button" class="btn btn-info">Cadastro</button>
                        </div>
                    </form>
                </div>
                
            </nav>
        Agora, no arquivo index.js de routes, precisamos realizar a seguinte modificação:
            module.exports = function(application){
                application.get('/', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('index');
                    application.app.controllers.index.index(application, req, res);
                });

                application.post('/autenticar', function(req, res){
                    // res.send('chegando aqui');
                    application.app.controllers.index.autenticar(application, req, res);
                });
            }
        Agora, no index.js de controllers vamos precisar realizar a seguinte implementação.
            module.exports.index = function(application, req, res) {
                res.render('index');
            }

            module.exports.autenticar = function(application, req, res) {
                // res.send('chegou no controller');

                var dadosForm = req.body;

                req.assert('usuario', 'Usuário não deve ser vazio').notEmpty();
                req.assert('senha', 'Senha não deve ser vazio').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao: erros});
                    return;
                }

                res.send('tudo ok para criar a sessão');
            }
        Agora, no index.ejs do views, precisamos criar uma div que exiba tais mensagens de erros.
            <div class="container">
				
				<% if(validacao.length > 0){ %>
					<div class="alert alert-danger">
						<strong>Atenção!</strong>
						<ul>
							<% for(var i = 0; i < validacao.length; i++) { %>
								<li><%=validacao[i].msg%></li>
							<% } %>
						</ul>
					</div>
				<% } %>

				<form class="form-inline form-entrar" action="/autenticar" method="post">
					<div class="form-group">				
						<input type="text" name="usuario" id="usuario" placeholder="Usuário" class="form-control" autocomplete="off" />
						<input type="password" name="senha" id="senha" placeholder="Senha" class="form-control" />
						<button type="submit" class="btn btn-success">Entrar</button>
						<button type="button" class="btn btn-info">Cadastro</button>
					</div>
				</form>
			</div>

    Aula 4 - Configurando o Express-Session em nossa aplicação:
        A aula anterior serviu para criar um ambiente que dê para realizar as implementações necessárias para podermos aplicar o middleware, express-session.
        Mas, antes disso, precisamos realizar um pequeno ajuste nas tratativas da tela index.ejs, pois quando colocamos usuários e senhas de forma correta e vamos para a tela "/autenticar", donde é exibido a msg "tudo ok para criar a sessão".
        A partir dessa tela, quando apagamos a rota "/autenticar" será exibido a seguinte msg
            ReferenceError: /home/leonardo/Documentos/estudos/mmorpg_got/app/views/index.ejs:24
                22| 			<div class="container">

                23| 				

            >> 24| 				<% if(validacao.length > 0){ %>

                25| 					<div class="alert alert-danger">

                26| 						<strong>Atenção!</strong>

                27| 						<ul>


            validacao is not defined
                at eval (eval at compile (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/ejs/lib/ejs.js:524:12), <anonymous>:11:8)
                at returnedFn (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/ejs/lib/ejs.js:555:17)
                at tryHandleCache (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/ejs/lib/ejs.js:203:34)
                at exports.renderFile [as engine] (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/ejs/lib/ejs.js:412:10)
                at View.render (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/view.js:128:8)
                at tryRender (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/application.js:640:10)
                at Function.render (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/application.js:592:3)
                at ServerResponse.render (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/response.js:971:7)
                at module.exports.index (/home/leonardo/Documentos/estudos/mmorpg_got/app/controllers/index.js:2:9)
                at /home/leonardo/Documentos/estudos/mmorpg_got/app/routes/index.js:5:37
                at Layer.handle [as handle_request] (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/layer.js:95:5)
                at next (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/route.js:137:13)
                at Route.dispatch (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/route.js:112:3)
                at Layer.handle [as handle_request] (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/layer.js:95:5)
                at /home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/index.js:281:22
                at Function.process_params (/home/leonardo/Documentos/estudos/mmorpg_got/node_modules/express/lib/router/index.js:335:12)
        No caso, está sendo lançado o erro acima, pois no index.ejs, dentro dela, tem a variável "validacao", donde não definimos.
        Para corrigirmos esse problema, precisamos definir a variável validacao no index.js do controllers.
            module.exports.index = function(application, req, res) {
                res.render('index', {validacao: {}});
            }

        Agora, sim, vamos importar o express-session e implementa-la.
        No caso, no arquivo server.js do diretório config, nela iremos realizar a seguinte alteração.
            /* importar o módulo do framework express */
            var express = require('express');

            /* importar o módulo do consign */
            var consign = require('consign');

            /* importar o módulo do body-parser */
            var bodyParser = require('body-parser');

            /* importar o módulo do express-validator */
            var expressValidator = require('express-validator');

            /* importar o módulo do express-validator */
            var expressSession = require('express-session');

            /* iniciar o objeto do express */
            var app = express();

            /* setar as variáveis 'view engine' e 'views' do express */
            app.set('view engine', 'ejs');
            app.set('views', './app/views');

            /* configurar o middleware express.static */
            app.use(express.static('./app/public'));

            /* configurar o middleware body-parser */
            app.use(bodyParser.urlencoded({extended: true}));

            /* configurar o middleware express-validator */
            app.use(expressValidator());

            // configura o middleware express-session
            app.use(expressSession({
                secret: 'Bla Bla',
                resave: false,
                saveUnitialized: false
            }));

            /* efetua o autoload das rotas, dos models e dos controllers para o objeto app */
            consign()
                .include('app/routes')
                .then('config/dbConnection.js')
                .then('app/models')
                .then('app/controllers')
                .into(app);

            /* exportar o objeto app */
            module.exports = app;

    Aula 5 - Autenticando usuários com Express-Session - parte 1:
        Agora que configuramos o controller e o middleware, express-session, vamos implementar a lógica que receberá os dados do formulário do login para validar com as informações salvas no banco de dados.
        Isso permitirar criar uma lógica que limite os tipos de acessos.
        No caso, no arquivo index.js de controllers, vamos realizar a seguinte alteração.
            module.exports.index = function(application, req, res) {
                res.render('index', {validacao: {}});
            }

            module.exports.autenticar = function(application, req, res) {
                // res.send('chegou no controller');

                var dadosForm = req.body;

                req.assert('usuario', 'Usuário não deve ser vazio').notEmpty();
                req.assert('senha', 'Senha não deve ser vazio').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao:erros});
                    return;
                }

                var connection = application.config.dbConnection;
                var UsuariosDAO =new application.app.models.UsuariosDAO(connection);

                UsuariosDAO.autenticar(dadosForm);

                res.send('tudo ok para criar a sessão');
            }
        Agora, vamos ter que pegar o arquivo UsuarioDAO.js e nela criar mais um protótipo, autenticar:
            function UsuariosDAO(connection) {
                // console.log('Mostrar conexão antes: ', connection);
                this._connection = connection();
                // console.log('Mostrar conexão depois: ', this._connection);
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // insert(usuario);
                // this._connection.open( function(err, mongoclient){
                //     mongoclient.collection('usuarios', function(err, collection){
                //         collection.insert(usuario);
                //     });
                // } );
                this._connection.collection('usuarios').insertOne(usuario);
            }

            UsuariosDAO.prototype.autenticar = function(usuario) {
                // console.log(usuario);
                // this._connection.collection('usuarios').find({usuario: {$eq: usuario.usuario}, senha: {$eq: usuario.senha}});
                this._connection.collection('usuarios').find(usuario).toArray(function(err, result){
                    console.log(result);
                });
                // this._connection.close();
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        No caso, acima é um teste. Agora, vamos para validação.
            function UsuariosDAO(connection) {
                // console.log('Mostrar conexão antes: ', connection);
                this._connection = connection();
                // console.log('Mostrar conexão depois: ', this._connection);
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // insert(usuario);
                // this._connection.open( function(err, mongoclient){
                //     mongoclient.collection('usuarios', function(err, collection){
                //         collection.insert(usuario);
                //     });
                // } );
                this._connection.collection('usuarios').insertOne(usuario);
            }

            UsuariosDAO.prototype.autenticar = function(usuario, req) {
                // console.log(usuario);
                // this._connection.collection('usuarios').find({usuario: {$eq: usuario.usuario}, senha: {$eq: usuario.senha}});
                this._connection.collection('usuarios').find(usuario).toArray(function(err, result){
                    // console.log(result);
                    if(result[0] != undefined) {
                        // Lembra quando colocamos o middleware express-session em server.js?
                        req.session.autorizado = true;
                    }
                });
                // this._connection.close();
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Além disso, no index.js do controllers, precisamos enviar o req tbm, pois acima está sendo solicitado para possibilitar a aplicação do middleware, express-session.
            module.exports.index = function(application, req, res) {
                res.render('index', {validacao: {}});
            }

            module.exports.autenticar = function(application, req, res) {
                // res.send('chegou no controller');

                var dadosForm = req.body;

                req.assert('usuario', 'Usuário não deve ser vazio').notEmpty();
                req.assert('senha', 'Senha não deve ser vazio').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao:erros});
                    return;
                }

                var connection = application.config.dbConnection;
                var UsuariosDAO =new application.app.models.UsuariosDAO(connection);

                UsuariosDAO.autenticar(dadosForm, req);

                res.send('tudo ok para criar a sessão');
            }
        Agora, vamos refinar mais ainda os métodos autenticação no UsuariosDAO.js
            function UsuariosDAO(connection) {
                // console.log('Mostrar conexão antes: ', connection);
                this._connection = connection();
                // console.log('Mostrar conexão depois: ', this._connection);
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // insert(usuario);
                // this._connection.open( function(err, mongoclient){
                //     mongoclient.collection('usuarios', function(err, collection){
                //         collection.insert(usuario);
                //     });
                // } );
                this._connection.collection('usuarios').insertOne(usuario);
            }

            UsuariosDAO.prototype.autenticar = function(usuario, req, res) {
                // console.log(usuario);
                // this._connection.collection('usuarios').find({usuario: {$eq: usuario.usuario}, senha: {$eq: usuario.senha}});
                this._connection.collection('usuarios').find(usuario).toArray(function(err, result){
                    // console.log(result);
                    if(result[0] != undefined) {
                        // Lembra quando colocamos o middleware express-session em server.js?
                        req.session.autorizado = true;
                    }

                    if(req.session.autorizado) {
                        res.send('Usuário foi encontrado no banco de dados!');
                    } else {
                        res.send('Usuário não existe no banco de dados!');
                    }
                });
                // this._connection.close();
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Para isso, será necessário tbm alterar no index.js de controllers
            module.exports.index = function(application, req, res) {
                res.render('index', {validacao: {}});
            }

            module.exports.autenticar = function(application, req, res) {
                // res.send('chegou no controller');

                var dadosForm = req.body;

                req.assert('usuario', 'Usuário não deve ser vazio').notEmpty();
                req.assert('senha', 'Senha não deve ser vazio').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    res.render('index', {validacao:erros});
                    return;
                }

                var connection = application.config.dbConnection;
                var UsuariosDAO =new application.app.models.UsuariosDAO(connection);

                UsuariosDAO.autenticar(dadosForm, req, res);

                // res.send('tudo ok para criar a sessão');
            }
        Lembrando só podemos ter um response, res, à cada request, req.
        Agora, vamos fazer, por meio do uso de middleware, express-session, sempre que um usuário logar uma única vez, nas próximas vezes, em que o mesmo acessar a mesma tela não precisar realizar novamente o login.
        No caso, para possibilitar isso, no arquivo UsuariosDAO.js, vamos colocar a seguinte configuração.
            function UsuariosDAO(connection) {
                // console.log('Mostrar conexão antes: ', connection);
                this._connection = connection();
                // console.log('Mostrar conexão depois: ', this._connection);
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // insert(usuario);
                // this._connection.open( function(err, mongoclient){
                //     mongoclient.collection('usuarios', function(err, collection){
                //         collection.insert(usuario);
                //     });
                // } );
                this._connection.collection('usuarios').insertOne(usuario);
            }

            UsuariosDAO.prototype.autenticar = function(usuario, req, res) {
                // console.log(usuario);
                // this._connection.collection('usuarios').find({usuario: {$eq: usuario.usuario}, senha: {$eq: usuario.senha}});
                this._connection.collection('usuarios').find(usuario).toArray(function(err, result){
                    console.log(result);
                    if(result[0] != undefined) {
                        // Lembra quando colocamos o middleware express-session em server.js?
                        req.session.autorizado = true;

                        req.session.usuario = result[0].usuario;
                        req.session.casa = result[0].casa;
                    }

                    if(req.session.autorizado) {
                        // res.send('Usuário foi encontrado no banco de dados!');
                        res.redirect("jogo");
                    } else {
                        // res.send('Usuário não existe no banco de dados!');
                        res.render("index", {validacao: {}});
                    }
                });
                // this._connection.close();
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Agora, é só testar novamente para ver se foi implementado da forma que esperamos.
        Vimos que para o usuário não cadastrado continuamos na mesma página de index.ejs, e se for um usuário que existe no banco de dados, então foi redirecionado à página de jogos.

    Aula 6 - Autenticando usuários com Express-Session - parte 2:
        Agora, vamos finalizar os métodos de autenticação. No caso, usando o cookie, para possibilitar ao usuário, uma vez logado na máquina, quando for acessar na mesma máquina, ele não precisar realizar login novamente.
        Primeiramente, precisamos restringir a rota do jogo, pois no formato atual, se simplesmente jogarnos na tela do navegador, localhost/jogo, é possível acessarmos a tela.
        Vamos precisar impedir que seja possível acessar essa tela de forma livre, mas, sim, somente mediante ao login.
        No caso, vamos tratar esse problema no arquivo jogo.js de controllers, mas vale ressaltar que a mesma tratativa é possível ser feito em jogo.js de routes.
            module.exports.jogo = function(application, req, res) {
                if(req.session.autorizado) {
                    res.render('jogo');
                } else {
                    res.send('Usuário precisa fazer o login!');
                }
            }
        Agora, ao abrir um navegador anônimo e nela tentarmos acessar a tela de jogo, vamos ver que não será possível!
        Já com o login válido , será possível realizar o acesso na tela.
        Existem tbm outros métodos de autenticação, como tokens.

    Aula 7 - Destruindo a sessão com Session.destroy():
        Vamos aprender a destruir a sessão, de modo que ao clicar no botão, não seja mais possível acessar a tela de jogo, a não ser que seja feita uma nova autenticação.
        No caso, usaremos o botão "sair" de jogo.ejs de views.
            <nav class="navbar navbar-default navbar-static-top">
                <div class="container">
                    <div class="form-group sair">
                        <button type="button" class="btn btn-info pull-right" id="btn_sair">Sair</button>
                    </div>
                </div>
            </nav>
        Além disso, usaremos o jquery, para conseguirmos definir as ações mediante ao evento de click.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });
                });
            </script>
        No caso, com as configurações acima, podemos realizar o teste entrando na tela jogo com o login válido e depois saindo dela clicando no botão "sair".
        Visto que está funcionando, agora, em jogo.js de routes, nela iremos configurar a tal rota que definimos no jogo.ejs de views acima.
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('jogo');
                    application.app.controllers.jogo.jogo(application, req, res);
                });

                application.get('/sair', function(req, res){
                    application.app.controllers.jogo.sair(application, req, res);
                });
            }
        Agora, em jogo.js de controllers, vamos renderizar essa rota sair que definimos.
            module.exports.jogo = function(application, req, res) {
                if(req.session.autorizado) {
                    res.render('jogo');
                } else {
                    res.send('Usuário precisa fazer o login!');
                }
            }

            module.exports.sair = function(application, req, res) {
                res.send('sair');
            }
        Agora, podemos testar se está tudo funcionando corretamente.
        Visto que está funcionando corretamente, vamos agora destruir a seção
            module.exports.jogo = function(application, req, res) {
                if(req.session.autorizado) {
                    res.render('jogo');
                } else {
                    res.send('Usuário precisa fazer o login!');
                }
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }
        Com o formato acima, podemos ver que está funcionando como esperávamos.

    Aula 8 - Opcional - Download dos arquivos MMORPG GOT:
        Opcional - Download dos arquivos MMORPG GOT
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto MMORPG GOT no estado em que se encontram na aula anterior.

        Bons estudos ;)

Seção 17 - MMORPG Game Of Thrones - Criando ações do Jogo:
    Aula 1 - Ajustando a bandeira da casa do jogador:
        Vamos verificar agora diversos cenários de problemas e suas soluções, na expectativa de que isso sejam úteis nos seus projetos futuros.
        Vamos, primeiro, ajustar as bandeiras.
        No caso, sempre que um jogador for logar no jogo, queremos exibir na tela de jogo de qual bandeira esse jogador pertence.
        Primeiro, note que, em UsuariosDAO.js no protótipo autenticar, nela fizemos a requisição de uma sessão que consta a casa, req.session.casa = result[0].casa;.
        Visto que isso foi feito, então em jogo.js de controllers, vamos precisar que tal casa seja chamado.
            module.exports.jogo = function(application, req, res) {
                if(req.session.autorizado) {
                    res.render('jogo', {img_casa: req.session.casa});
                } else {
                    res.send('Usuário precisa fazer o login!');
                }
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }
        Feito isso, em jogo.ejs, na div img, vamos chamar essa variável que definimos.
            <div class="col-sm-3 casa">
                <img src="images/casa_<%=img_casa%>.jpg" />
            </div>
        Daí, ao logarmos, se tudo ocorreu certo, vamos poder verificar a casa em que o usuário pertence e a sua bandeira estará sendo exibido.
        Ou seja, a imagem da bandeira foi carregada.
        No caso, agora, as bandeiras da casa para exibição foi dinamizada.

    Aula 2 - Gerando pontos de habilidade, súditos e moedas:
        Vamos dar mais dinâmica para o nosso jogo.
        O que queremos fazer aqui é definir as qualidade pré-inatas de quando cada pessoa escolha as casas na qual ela acha que mais se adequa.
        Entretanto, definir para cada casa uma qualidade pré-definida, precisaria de mais alguns conceitos que foge fora do escopo do que queremos ensinar nesse curso.
        Logo, por hora, vamos fazer com que tais qualidades, independente de qual casa escolhida, seja feita de forma randomica.
        Vamos criar um novo arquivo no models com nome JogoDAO.js.
        Esse arquivo vai manipular os documentos dentro da collection jogo.
        Dentro desse arquivo, vamos colocar a seguinte configuração
            function JogoDAO(connection) {
                this._connection = connection();
            }

            module.exports = function(){
                return JogoDAO;
            }
        Por hora, são configurações básicas.
        Além disso, no cadastro.js de controllers, precisamos enviar tais qualidades de cada casa que será definido de forma randômica.
        Para isso, nesse arquivo será criado algo que esteja relacionado à geração dos parâmetros.
        Mas antes disso, vamos pegar o arquivo jogoDAO.js e dentro dela configurar as funções que irá receber tais parâmetros.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Agora, no cadastro.js de controllers, vamos precisar realizar a seguinte customização.
            module.exports.cadastro = function(application, req, res){
                res.render('cadastro', {validacao: {}, dadosForm: {}});
            }

            module.exports.cadastrar = function(application, req, res) {
                // res.send('Teste - vamos cadastrar!');
                var dadosForm = req.body;
                req.assert('nome', 'Nome não pode ser vazio!').notEmpty();
                req.assert('usuario', 'Usuário não pode ser vazio!').notEmpty();
                req.assert('senha', 'Senha não pode ser vazio!').notEmpty();
                req.assert('casa', 'Casa não pode ser vazio!').notEmpty();

                var erros = req.validationErrors();

                if(erros) {
                    // res.send('Existem erros no formulário!');
                    res.render('cadastro', {validacao: erros, dadosForm: dadosForm});
                    return;
                }

                var connection = application.config.dbConnection;
                // console.log('Estado da conexão: ', connection);
                var UsuariosDAO = new application.app.models.UsuariosDAO(connection);
                var JogoDAO = new application.app.models.JogoDAO(connection);

                UsuariosDAO.inserirUsuario(dadosForm);
                JogoDAO.gerarParametros(dadosForm.usuario);

                // geracao dos parametros

                res.send('Podemos cadastrar!');
            }
        Feito as configurações acima, vamos realizar os testes.
        Cada vez que fizermos os cadastros, no banco de dados, MongoDB, será criado uma coleção jogo e dentro dela será acrescentado as informações pré-definidas do usuário.

    Aula 3 - Exibindo pontos de habilidades, súditos e moedas:
        Agora que estamos gerando os parâmetros acima no banco de dados, precisamos que elas sejam exibidas.
        No caso, em jogo.js de controllers, vamos precisar configurar para possibilitar essa exibição.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var usuario = req.session.usuario;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(usuario);
                res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }
        Vale lembrar que a variável usuario que foi criado acima, só foi possível por conta do que está em UsuarioDAO quando validamos o req.session.usuario.
        Agora, em jogoDAO.js de models, vamos criar a função iniciaJogo onde irá requisitar as informações dos parâmetros no banco de dados.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(usuario) {
                console.log('Iniciar os parâmetros do jogo');
            }

            module.exports = function(){
                return JogoDAO;
            }
        A forma acima será feita para podermos realizar o teste.
        No caso, precisamos acessar com um login válido da tela de jogo, para verificarmos se está tudo funcionando corretamente.
        Visto que está funcionando, vamos implementar a lógica em jogoDAO.js.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(usuario) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    console.log(result);
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        No caso, dentro do jogoDAO.js da função iniciaJogo, vamos precisar renderizar a tela de jogo para podermos enviar os dados de cada parâmetro.
        Para isso, antes em jogo.js, vamos precisar enviar mais algumas informações dentro dessa função iniciaJogo.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }
        Daí, em jogoDAO.js, vamos precisar colocar mais variáveis para receberem mais parâmetros.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    console.log(result[0]);
                    res.render('jogo', {img_casa: casa, jogo: result[0]});
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Por último, em jogo.ejs, vamos precisar exibir tais parâmetros.
            <div class="container">
	    	
                <div class="row">
                    <div class="col-sm-3 casa">
                        <img src="images/casa_<%=img_casa%>.jpg" />
                    </div>

                    <div class="col-sm-9">
                        <div class="row barra-superior">
                            <div class="col-sm-2"> 
                                <img src="images/habilidades/temor.jpg" title="Temor" alt="Temor" />
                                <span><%=jogo.temor%></span>
                            </div>
                            
                            <div class="col-sm-2"> 
                                <img src="images/habilidades/sabedoria.jpg" title="Sabedoria" alt="Sabedoria"/>
                                <span><%=jogo.sabedoria%></span>
                            </div>
                            
                            <div class="col-sm-2"> 
                                <img src="images/habilidades/comercio.jpg" title="Comércio" alt="Comércio"/>
                                <span><%=jogo.comercio%></span>
                            </div>
                            
                            <div class="col-sm-2"> 
                                <img src="images/habilidades/magia.jpg" title="Magia" alt="Magia"/>
                                <span><%=jogo.magia%></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-sm-3"></div>
                    <div class="col-sm-9">
                        <div class="acoes"></div>					
                    </div>
                </div>
                
            </div>	
            
            <div class="barra-inferior">
                <div class="container">
                
                    <div class="row">
                        <div class="col-sm-1">
                            <img src="images/outros/suditos.jpg" title="Aldeões" alt="Aldeões"/>
                            <span><%=jogo.suditos%></span>
                        </div>
                        
                        <div class="col-sm-1">
                            <img src="images/outros/pergaminho.jpg" title="Pergaminhos" alt="Pergaminhos"/>
                        </div>
                        
                        <div class="col-sm-8"></div>
                        
                        <div class="col-sm-2">
                            <img src="images/outros/moeda.jpg" title="Moeda" alt="Moeda"/>
                            <span><%=jogo.moeda%></span>
                        </div>
                        
                    </div>
                </div>
            </div>
        Assim, vemos que já estão sendo exibidos os parâmetros em cada lugar.

    Aula 4 - Carregando as views de súditos e pergaminhos via Ajax com JQuery:
        Vamos aprender a carregar as views correspondentes aos súditos e ao pergaminho.
        No caso, no diretório views, temos dois arquivos, aldeoes.ejs e pergaminhos.ejs.
        Vamos precisar carregar ela utilizando o método ajax, através de uma requisição assíncrona.
        No caso, em jogo.js de routes, vamos criar mais duas rotas.
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('jogo');
                    application.app.controllers.jogo.jogo(application, req, res);
                });

                application.get('/sair', function(req, res){
                    application.app.controllers.jogo.sair(application, req, res);
                });

                application.get('/suditos', function(req, res){
                    application.app.controllers.jogo.suditos(application, req, res);
                });

                application.get('/pergaminhos', function(req, res){
                    application.app.controllers.jogo.pergaminhos(application, req, res);
                });
            }
        No caso, com a rota configurada, vamos precisar, agora, definir as funções correspondentes de cada rota definida.
        Assim, no jogo.js de controllers, vamos definir tais funções.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                res.render("pergaminhos");
            }
        No caso, definidas as duas funções, suditos e pergaminhos, acima podemos agora acessar tais rotas ao jogarmos no navegador.
        Visto que as rotas acimas estão sendo possíveis em serem acessadas, vamos precisar que tais acessos sejam permitidos apenas quando acessarmos a tela jogo.
        No caso, primeiro, em jogo.ejs vamos definir a possibilitar em acessar tais rotas.
            <div class="row">
				<div class="col-sm-3"></div>
				<div class="col-sm-9">
					<div class="acoes" id="acoes">Senhor, o que deseja fazer hoje?</div>					
				</div>
			</div>
        Agora, iremos aplicar o método ajax para realizar isso.
        Assim, no mesmo arquivo jogo.ejs, vamos colocar as seguintes configurações
            <div class="row">
                <div class="col-sm-1">
                    <img src="images/outros/suditos.jpg" title="Aldeões" alt="Aldeões" id="btn_suditos"/>
                    <span><%=jogo.suditos%></span>
                </div>
                
                <div class="col-sm-1">
                    <img src="images/outros/pergaminho.jpg" title="Pergaminhos" alt="Pergaminhos" id="btn_pergaminho"/>
                </div>
                
                <div class="col-sm-8"></div>
                
                <div class="col-sm-2">
                    <img src="images/outros/moeda.jpg" title="Moeda" alt="Moeda"/>
                    <span><%=jogo.moeda%></span>
                </div>
                
            </div>
        Basicamente, as configurações estabelecidas acima, em criar os ids, será definida o evento de click sobre elas para possibilitar o acesso à telas aldeoes e pergaminhos definidas pelas rotas anteriormente.
        No caso, no mesmo arquivo, jogo.ejs, será usado javascript para definirmos tais eventos.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        alert('BTN suditos clicado');
                    });

                    $('#btn_pergaminho').click(function(){
                        alert('BTN pergaminho clicado');
                    });
                });
            </script>
        Daí, agora, podemos testar se está sendo possível clicar em suditos e pergaminhos acessando a tela de jogo.
        No caso, a configuração acima, é apenas um "Hello World", então visto que está sendo exibido a msg, podemos agora usar o ajax para configurarmos definitivamente a rota
        No caso, podemos entender que o ajax é uma espécie de components de vue (explicação para quem sabe vue). Ou seja, vc consegue exibir uma tela inteira dentro de uma outra tela.
        Logo, em jogo.ejs, vamos realizar a seguinte configuração.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        })
                    });
                });
            </script>

    Aula 5 - Ações com súditos - recebendo e validando dados:
        Vamos implementar o formulário que permitirá realizar as ações com os súditos.
        No caso, no arquivo aldeoes.ejs vamos definir o seguinte na tag form
            <form class="form-cadastro" action="/ordenar_acao_sudito" method="post">

                <div class="row">
                    <div class="col-xs-5">
                        <div class="form-group">
                            <select class="form-control" name="acao">
                                <option value="">-- Escolha a ação</option>
                                <option value="1">Coletar recursos (2G e 1H)</option>
                                <option value="2">Enforcar aldeão (3G e 2H)</option>
                                <option value="3">Ensinar história (1G e 5H)</option>
                                <option value="4">Ensinar magia (1G e 5H)</option>
                            </select>										
                        </div>
                    </div>
                    
                    <div class="col-xs-3">
                        <div class="form-group">
                            <input type="number" class="form-control" name="quantidade" id="quantidade" placeholder="Quantidade">									
                        </div>
                    </div>
                    
                    <div class="col-xs-4">
                        <div class="form-group row">
                            <button type="submit" class="btn btn-primary">Ordenar</button>
                        </div>
                    </div>
                    
                </div>
                
                <hr />
                <div class="row">
                    <div class="col-xs-12">
                        <span>Senhor, você possui 8 aldeões desocupados e 2 aldeões em atividade.</span>
                    </div>
                </div>
            </form>
        Agora, falta ajustarmos as nossas rotas para tais finalidades que queremos.
        No caso, em jogo.js de routes, iremos configurar da seguinte maneira.
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('jogo');
                    application.app.controllers.jogo.jogo(application, req, res);
                });

                application.get('/sair', function(req, res){
                    application.app.controllers.jogo.sair(application, req, res);
                });

                application.get('/suditos', function(req, res){
                    application.app.controllers.jogo.suditos(application, req, res);
                });

                application.get('/pergaminhos', function(req, res){
                    application.app.controllers.jogo.pergaminhos(application, req, res);
                });

                application.post('/ordenar_acao_sudito', function(req, res){
                    application.app.controllers.jogo.ordenar_acao_sudito(application, req, res);
                });
            }
        Agora, em jogo.js de controllers, vamos definir tais funções que estamos chamando nas rotas.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo');
                    return;
                }

                console.log(dadosForm);
                res.send('tudo ok!');
            }
        Com o formato acima, podemos testar o que estará acontecendo acessando pelo navegador acessando a tela de jogo, novamente, pelo login e em seguida clicar em súditos escolher a ação pelo filtro e clicar em "Ordenar".
        Se apareceu a msg "tudo ok!" e no console, pelo nodemon, aparecer algo do seguinte tipo
            [nodemon] restarting due to changes...
            [nodemon] starting `node app`
            express-session deprecated undefined saveUninitialized option; provide saveUninitialized option config/server.js:33:9
            consign v0.1.6 Initialized in /home/leonardo/Documentos/estudos/mmorpg_got
            + ./app/routes/cadastro.js
            + ./app/routes/index.js
            + ./app/routes/jogo.js
            + ./config/dbConnection.js
            + ./app/models/UsuariosDAO.js
            + ./app/models/jogoDAO.js
            + ./app/controllers/cadastro.js
            + ./app/controllers/index.js
            + ./app/controllers/jogo.js
            Servidor online
            Conectado com sucesso no banco de dados MongoDB Community Edition!
            [
            {
                _id: new ObjectId("63ade4f86ce4e9192dc73ac5"),
                nome: 'Leonardo',
                usuario: 'MadScientistWithDepression',
                senha: '123456',
                casa: 'targaryen'
            }
            ]
            Conectado com sucesso no banco de dados MongoDB Community Edition!
            {
            _id: new ObjectId("63ade4f86ce4e9192dc73ac6"),
            usuario: 'MadScientistWithDepression',
            moeda: 15,
            suditos: 10,
            temor: 98,
            sabedoria: 197,
            comercio: 836,
            magia: 709
            }
            { acao: '2', quantidade: '1' }
        Ou seja, o objeto onde consta os elementos acao e quantidade, então significa que tudo está funcionando corretamente.
        Além disso, se eu deixar de preencher alguma informação, ela deverá. como foi configurado, voltar para tela jogo.
        Novamente, vamos precisar tbm exibir tais erros para instruir melhor o usuário.
        Temos duas formas de realizarmos isso, uma utilizando o banco de dados e outra utilizando o método mais simples como foi feito abaixo.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var comando_invalido = 'N';

                if(req.query.comando_invalido == 'S') {
                    comando_invalido = 'S';
                }

                console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo?comando_invalido=S');
                    return;
                }

                console.log(dadosForm);
                res.send('tudo ok!');
            }
        Vemos que se testarmos agora com o formato acima, será exibido no console.log a msg de N mudando para S. 
        Se preenchermos os dados a meia boca, será redirecionado na rota 'jogo?comando_invalido=S'.
        Visto que isso funciona, então vamos precisar agora ecaminhar tal variável que definimos para jogoDAO.iniciaJogo.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var comando_invalido = 'N';

                if(req.query.comando_invalido == 'S') {
                    comando_invalido = 'S';
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo?comando_invalido=S');
                    return;
                }

                console.log(dadosForm);
                res.send('tudo ok!');
            }
        Agora, em jogoDAO.js em models, vamos precisar recuperar essa informação incluída.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, comando_invalido) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    console.log(result[0]);
                    res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Em seguida, em jogo.ejs, vamos precisar verificar tal variável para conseguirmos exibir se caso ocorrer algum erro.
            <% if(comando_invalido == 'S') {%>
				<div class="alert alert-danger">
					<strong>Operação inválida, verifique se todos os campos foram informados!</strong>
				</div>
			<%} %>
        Daí, vamos verificar se está sendo expressa tal mensagem testando todas as possibilidades de erros e acertos que aconteceria.
        Para melhor maneira de exibição da msg na tela sem que ocorra alguma distorção, vamos precisar colocar a seguinte configuração em jogo.ejs.
            <% if(comando_invalido == 'S') {%>
				<div class="alert alert-danger" id="msg_erros">
					<strong>Operação inválida, verifique se todos os campos foram informados!</strong>
				</div>
			<%} %>
        E
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $('#msg_erros').hide();
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $('#msg_erros').hide();
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        })
                    });
                });
            </script>
        Daí, sempre que clicarmos novamente em súditos, vamos conseguir verificar que a msg de erro desaparece.
        Agora, falta possibilitar o acesso às telas de súditos e pergaminhos somente quando verificarmos que o usuário está autenticado.
        Para isso, realizamos a mesma lógica que foi implementada para restringir o acesso à tela de jogo.
        No caso, em jogo.js de controllers, vamos realizar a seguinte configuração.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var comando_invalido = 'N';

                if(req.query.comando_invalido == 'S') {
                    comando_invalido = 'S';
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo?comando_invalido=S');
                    return;
                }

                console.log(dadosForm);
                res.send('tudo ok!');
            }
        Feito a configuração acima, vamos poder restringir o acesso à telas jogo, suditos, pergaminhos e ordenar_acao_sudito.

    Aula 6 - Gravando ações no banco de dados:
        Agora, vamos aprender a gravar ações no banco de dados.
        O motivo disso, seria que as ações dos usuários afetem na dinâmica do jogo, mas para que isso aconteça, de alguma forma, a informação precisa estar sendo cadastrada no banco de dados de tal forma que a ação tenha uma dinâmica permanente.
        No caso, o que quero dizer com tais dinâmicas, está relacionado às quantidades de súditos, moedas, habilidades, etc... Aquelas nas quais são dados númericos com seus respectivos significados.
        Logo, iremos acessar o banco de dados MongoDB, para gravarmos tais ações que permita ta tal dinâmica.
        No caso, vamos abrir o jogo.js de controllers e por lá realizar as devidas tratativas.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var comando_invalido = 'N';

                if(req.query.comando_invalido == 'S') {
                    comando_invalido = 'S';
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo?comando_invalido=S');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.acao(dadosForm);
            }
        Após isso, em jogoDAO.js de models vamos realizar a seguinte modificação.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, comando_invalido) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    console.log(result[0]);
                    res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                console.log(acao);
            }

            module.exports = function(){
                return JogoDAO;
            }
        No caso, a forma como configuramos a função acao acima, serve para primeiro verificar se está sendo feito o "Hello World!".
        No caso, logamos novamente e executação alguma acao pelo súditos.
        Visto que está tudo funcionando corretamente, e visto que o dadosForm está sendo enviado corretamente na função acao de jogoDAO.js, iremos, finalmente, inserir a gravação de tais ações no banco de dados.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, comando_invalido) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    console.log(result[0]);
                    res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                this._connection.collection('acao', function(err, collection){
                    var date = new Date();

                    var tempo = null;

                    switch(acao.acao) {
                        case 1: tempo = 1*60*60000;
                        case 2: tempo = 2*60*60000;
                        case 3: tempo = 5*60*60000;
                        case 4: tempo = 5*60*60000;
                    }

                    acao.acao_terminal_em = date.getTime() + tempo;
                    collection.insertOne(acao);
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Além disso, em jogo.js de controllers, precisamos inserir mais uma informação dentro do objeto dadosForm, que é o usuário, pois precisamos saber à qual usuário cada ação está sendo estabelecido.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                var comando_invalido = 'N';

                if(req.query.comando_invalido == 'S') {
                    comando_invalido = 'S';
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                if(erros){
                    res.redirect('jogo?comando_invalido=S');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                res.send('tudo ok!');
            }
        Com isso, podemos ver que tais ações estão sendo cadastrados no banco de dados.
        Vimos que os comandos foram realizados com sucesso e conseguimos cadastrar cada acao na coleção "acao" do banco de dados.
        Para refinarmos as melhoras em sabermos se tais ações foram ou não executados, vamos em jogo.js controllers e nela configurar a função ordenar_acao_sudito  da seguinte forma.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // var comando_invalido = 'N';

                // if(req.query.comando_invalido == 'S') {
                //     comando_invalido = 'S';
                // }

                var msg = '';

                if(req.query.msg != ''){
                    msg = req.query.msg;
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                // JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                JogoDAO.iniciaJogo(res, usuario, casa, msg);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                // if(erros){
                //     res.redirect('jogo?comando_invalido=S');
                //     return;
                // }

                if(erros){
                    res.redirect('jogo?msg=A');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                // res.send('tudo ok!');
                res.redirect('jogo?msg=B');
            }
        A mudança configurada irá perpetuar para jogoDAO.js e nela precisará configurar o seguinte
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(acao.acao) {
                    case 1: tempo = 1*60*60000;
                    case 2: tempo = 2*60*60000;
                    case 3: tempo = 5*60*60000;
                    case 4: tempo = 5*60*60000;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);
            }

            module.exports = function(){
                return JogoDAO;
            }
        E, por final, vamos precisar alterar em jogo.ejs.
            <% if(msg == 'A') {%>
				<div class="alert alert-danger" id="msg">
					<strong>Operação inválida, verifique se todos os campos foram informados!</strong>
				</div>
			<%} %>

			<% if(msg == 'B') {%>
				<div class="alert alert-info" id="msg">
					<strong>Ação realizada com sucesso!</strong>
				</div>
			<%} %>

    Aula 7 - Pergaminhos - recuperando ações do banco de dados:
        Vamos, agora, recuperar tais ações em pergaminhos, visto que tais ações foram gravadas no banco de dados.
        Por hora, vamos apenas listar os objetos.
        Para isso, iremos usar a função jogo.js de controllers e nela usar a função pergaminhos que foi definido.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // var comando_invalido = 'N';

                // if(req.query.comando_invalido == 'S') {
                //     comando_invalido = 'S';
                // }

                var msg = '';

                if(req.query.msg != ''){
                    msg = req.query.msg;
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                // JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                JogoDAO.iniciaJogo(res, usuario, casa, msg);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // recuperar as ações inseridas no banco de dados.
                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                JogoDAO.getAcoes();

                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                // if(erros){
                //     res.redirect('jogo?comando_invalido=S');
                //     return;
                // }

                if(erros){
                    res.redirect('jogo?msg=A');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                // res.send('tudo ok!');
                res.redirect('jogo?msg=B');
            }
        Agora, em jogoDAO.js, vamos precisar definir a função que foi chamado na função pergaminhos.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(acao.acao) {
                    case 1: tempo = 1*60*60000;
                    case 2: tempo = 2*60*60000;
                    case 3: tempo = 5*60*60000;
                    case 4: tempo = 5*60*60000;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);
            }

            JogoDAO.prototype.getAcoes = function(acao) {
                console.log('recuperar acoes');
            }

            module.exports = function(){
                return JogoDAO;
            }
        No caso, o prototipo getAcoes definida acima vamos verificar se está sendo passado por lá.
        Para isso no navegador, precisamos relogar novamente para entrar na tela de jogo e clicar em pergaminhos para verificar se o console.log é exibido.
        Visto que está passando pela função getAcoes, então vamos agora implementar os códigos que recupera os dados dentro do banco de dados.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(acao.acao) {
                    case 1: tempo = 1*60*60000;
                    case 2: tempo = 2*60*60000;
                    case 3: tempo = 5*60*60000;
                    case 4: tempo = 5*60*60000;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);
            }

            JogoDAO.prototype.getAcoes = function(usuario) {
                // console.log('recuperar acoes');
                this._connection.collection('acao').find({usuario: usuario}).toArray(function(err, result) {
                    console.log(result);
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Além disso, em jogo.js de controllers, vamos precisar passar o dado do usuário para podermos filtrar qual tipo de dado precisa ser recuperado.
        No caso, na função pergaminho precisamos, por ela, enviar tal parâmetro.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // var comando_invalido = 'N';

                // if(req.query.comando_invalido == 'S') {
                //     comando_invalido = 'S';
                // }

                var msg = '';

                if(req.query.msg != ''){
                    msg = req.query.msg;
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                // JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                JogoDAO.iniciaJogo(res, usuario, casa, msg);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // recuperar as ações inseridas no banco de dados.
                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                var usuario = req.session.usuario;

                JogoDAO.getAcoes(usuario);

                res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                // if(erros){
                //     res.redirect('jogo?comando_invalido=S');
                //     return;
                // }

                if(erros){
                    res.redirect('jogo?msg=A');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                // res.send('tudo ok!');
                res.redirect('jogo?msg=B');
            }
        Daí, podemos, agora, testar se está tudo funcionando relogando novamente na tela de jogos e clicando em pergaminhos.

    Aula 8 - Pergaminhos - exibindo ações:
        Visto que agora estamos conseguindo recuperar os dados de cada ação, agora, vamos precisar exibi-las.
        Assim, em jogoDAO.js, na função getAcoes, vamos renderizar a tela pergaminhos passando os parâmetros que estamos recuperando pelo banco de dados.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(acao.acao) {
                    case 1: tempo = 1*60*60000;
                    case 2: tempo = 2*60*60000;
                    case 3: tempo = 5*60*60000;
                    case 4: tempo = 5*60*60000;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);
            }

            JogoDAO.prototype.getAcoes = function(usuario, res) {
                // console.log('recuperar acoes');
                this._connection.collection('acao').find({usuario: usuario}).toArray(function(err, result) {
                    // console.log(result);
                    res.render('pergaminhos', {acoes: result})
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Além disso, em jogo.js de controllers, vamos precisar enviar o objeto res para o getAcoes que foi definido em jogoDAO.js.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // var comando_invalido = 'N';

                // if(req.query.comando_invalido == 'S') {
                //     comando_invalido = 'S';
                // }

                var msg = '';

                if(req.query.msg != ''){
                    msg = req.query.msg;
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                // JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                JogoDAO.iniciaJogo(res, usuario, casa, msg);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // recuperar as ações inseridas no banco de dados.
                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                var usuario = req.session.usuario;

                JogoDAO.getAcoes(usuario, res);

                // res.render("pergaminhos");
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                // if(erros){
                //     res.redirect('jogo?comando_invalido=S');
                //     return;
                // }

                if(erros){
                    res.redirect('jogo?msg=A');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                // res.send('tudo ok!');
                res.redirect('jogo?msg=B');
            }
        Agora, em pergaminho.ejs, nela iremos listar as ações que recuperamos no banco de dados.
        Visto que está tudo rodando normalmente, então vamos agora preencher os dados de forma correta.
        Assim, em pergaminhos.ejs, vamos realizar a seguinte modificação.
            <div id="pergaminhos">					
                <h3>Pergaminhos</h3>
                
                <ul>
                    <% for(var i = 0; i < acoes.length; i++) { %>
                        <%
                            var txt_acao = '';

                            switch(parseInt(acoes[i].acao)){
                                case 1: txt_acao = 'Aldeão(ões) coletando recursos'; break;
                                case 2: txt_acao = 'Enforcar Aldeões'; break;
                                case 3: txt_acao = 'aldeão(ões) em treinamento de história'; break;
                                case 4: txt_acao = 'aldeão(ões) em treinamento de magia'; break;
                            }

                            var date = new Date();
                            var momento_atual = date.getTime();

                            var segundos_restantes = Math.round((acoes[i].acao_terminal_em - momento_atual) / 1000);
                        %>
                        <li>
                            <%=acoes[i].quantidade%> <%=txt_acao%>
                            - <small>restam <%=segundos_restantes%> segundos 
                            - <a href="#">revogar ordem</a></small>
                        </li>
                    <% } %>
                </ul>
            </div>
        Com isso, ao relogarmos para a tela jogo e clicarmos no pergaminho será exibido o tempo em segundos. Entretanto, esse tempo ele não está em exibição em tempo real.
        Será necessário colocar em um formato de cronômetro onde a contagem seja exibido em tempo real.

    Aula 9 - Criando um cronometro para controlar o tempo das ações:
        Vamos configurar o cronômetro.
        Para isso, no jogoDAO.js da função getAcoes, nela vamos definir um outro parâmetro dentro de find.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(parseInt(acao.acao)) {
                    case 1: tempo = 1*60*60000; break;
                    case 2: tempo = 2*60*60000; break;
                    case 3: tempo = 5*60*60000; break;
                    case 4: tempo = 5*60*60000; break;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);
            }

            JogoDAO.prototype.getAcoes = function(usuario, res) {
                // console.log('recuperar acoes');
                var date = new Date();
                var momento_atual = date.getTime();
                this._connection.collection('acao').find({usuario: usuario, acao_terminal_em: {$gt:momento_atual}}).toArray(function(err, result) {
                    // console.log(result);
                    res.render('pergaminhos', {acoes: result})
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Daí, feito isso, percebe-se que em pergaminhos não será mais exibido as ações que já superaram o tempo.
        Agora, vamos automotizar a contagem de tempo e exibir o mesmo.
        No caso, em jogo.ejs na parte de script onde tempo jquery de btn_pergaminhos, vamos realizar a seguinte modificação.

        Além disso, em pergaminhos.ejs, vamos precisar definir a tal classe que chamamos para realizarmos a contagem de menos.
            <div id="pergaminhos">					
                <h3>Pergaminhos</h3>
                
                <ul>
                    <% for(var i = 0; i < acoes.length; i++) { %>
                        <%
                            var txt_acao = '';

                            switch(parseInt(acoes[i].acao)){
                                case 1: txt_acao = 'Aldeão(ões) coletando recursos'; break;
                                case 2: txt_acao = 'Enforcar Aldeões'; break;
                                case 3: txt_acao = 'aldeão(ões) em treinamento de história'; break;
                                case 4: txt_acao = 'aldeão(ões) em treinamento de magia'; break;
                            }

                            var date = new Date();
                            var momento_atual = date.getTime();

                            var segundos_restantes = Math.round((acoes[i].acao_terminal_em - momento_atual) / 1000);
                        %>
                        <li>
                            <%=acoes[i].quantidade%> <%=txt_acao%>
                            - <small>restam <span class="tempo_restante"><%=segundos_restantes%></span> segundos 
                            - <a href="#">revogar ordem</a></small>
                        </li>
                    <% } %>
                </ul>
            </div>
        Obs: precisa ser uma classe, em vez de id, devido ao id ser um identificador único. Como haverá casos em que as ações serão mais de uma listada, precisamos que tais contagem sejam efetuadas em todas as ações.
        No caso, a classe ela tem essa natureza uniforme, diferente de id, que é um identificador único que tem como natureza algo muito local e único.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);

                                cronometro();
                            }
                        })
                    });
                });

                function cronometro(){
                    $('.tempo_restante').each(function(){
                        var segundos = $(this).html();
                        alert(segundos);
                    })
                }
            </script>
        Agora, podemos verificar se está funcionando.
        Agora, falta decrementar o valor, visto que estamos buscando os dados corretos.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);

                                cronometro();
                            }
                        })
                    });
                });

                function cronometro(){
                    $('.tempo_restante').each(function(){
                        var segundos = $(this).html();
                        var segundos_atuais = parseInt(segundos) - 1;

                        $(this).html(segundos_atuais);
                        // alert(segundos);
                    })

                    setTimeout('cronometro()', 1000);
                }
            </script>
        Note que, conseguimos configurar um ciclo de iteração de funções.
        Tal configuração, acima possibilitará a exibição da mesma a diminuição de tempo à cada segundo.
        Porém, ainda temos um problema a ser resolvido nisso.
        Note que, no formato atual, ao clicarmos em pergaminhos ela será exibido o tempo restante e que o mesmo está diminuindo a cada segundo em que é definido no setTimeout.
        Porém, o problema é que conseguimos acelerar a redução de tempo clicando no botão pergaminho várias vezes.
        Isso é um problema, pois a contagem ficará mais rápido do que a cada 1 segundos definidos, a priori.
        Para resolvermos esse problema, precisamos realizar o seguinte.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                                
                                clearTimeout(timerId);
                                cronometro();
                            }
                        })
                    });
                });

                var timerId = null ; 

                function cronometro(){
                    $('.tempo_restante').each(function(){
                        var segundos = $(this).html();
                        var segundos_atuais = parseInt(segundos) - 1;

                        $(this).html(segundos_atuais);
                        // alert(segundos);
                    })

                    timerId = setTimeout('cronometro()', 1000);
                }
            </script>   
        No caso, definimos a variável timertId e combinamos com o clearTimeout.
        Isso resolverá o problema, pois a lógica por trás disso seria que sempre que reacessarmos novamente, clicando no botão pergaminhos, sempre o timerId ela será resetado em null, e isso evitará de que o tempo sejá descontado conforme a velocidade do seu click, pois a cada click ela iniciará do último número em que foi descontado os 1 segundos.
        Falta agora tratar o caso em que o tempo ficar no 0.

    Aula 10 - Tratando o instante 0 do cronometro:
        Vamos, agora, tratar o caso em que a contagem chega em 0.
        Para isso, bastaríamos colocar mais uma condicional no script de jogo.ejs que configuramos a função cronometro.
            <script>
                $(document).ready( function(){
                    $('#btn_sair').click(function(){
                        window.location.href = '/sair';
                    });

                    $('#btn_suditos').click(function(){
                        // alert('BTN suditos clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/suditos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                            }
                        });
                    });

                    $('#btn_pergaminho').click(function(){
                        // alert('BTN pergaminho clicado');
                        $('#msg').hide();
                        $.ajax({
                            url: '/pergaminhos',
                            method: "get",
                            success: function(data){
                                $('#acoes').html(data);
                                
                                clearTimeout(timerId);
                                cronometro();
                            }
                        })
                    });
                });

                var timerId = null ; 

                function cronometro(){
                    $('.tempo_restante').each(function(){
                        var segundos = $(this).html();
                        var segundos_atuais = parseInt(segundos) - 1;

                        if(segundos_atuais < 0) {
                            window.location.href = "/jogo?msg=C";
                        } else {
                            $(this).html(segundos_atuais);
                        }
                        // alert(segundos);
                    })

                    timerId = setTimeout('cronometro()', 1000);
                }
            </script>
        E
            <% if(msg == 'C') {%>
				<div class="alert alert-info" id="msg">
					<strong>Senhor, a atividade ordenada foi finalizada!</strong>
				</div>
			<%} %>
        No caso, quando a contagem chegar no zero, será exibida a msg anterior.
        Agora, podemos testar o mesmo mudando manualmente o valor do tempo que está sendo exibido dentro da classe tempo_restante.

    Aula 11 - Atualizando moedas:
        Vamos, agora atualizar as moedas cada vez que conseguimos finalizar as ações de forma bem sucedida.
        No caso, como na função ordenar_acao_sudito definido em jogo.js de controllers, nela chama-se a função acao que está definido em jogoDAO.js, então vamos definir dentro dessa função, acao, uma outra atualização para a moeda.
            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(parseInt(acao.acao)) {
                    case 1: tempo = 1*60*60000; break;
                    case 2: tempo = 2*60*60000; break;
                    case 3: tempo = 5*60*60000; break;
                    case 4: tempo = 5*60*60000; break;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);

                var moedas = null;

                switch(parseInt(acao.acao)) {
                    case 1: moedas = -2 * parseInt(acao.quantidade); break;
                    case 2: moedas = -3 * parseInt(acao.quantidade); break;
                    case 3: moedas = -1 * parseInt(acao.quantidade); break;
                    case 4: moedas = -1 * parseInt(acao.quantidade); break;
                }

                this._connection.collection('jogo').updateMany({ usuario: acao.usuario }, { $inc: {moeda: moedas} });
            }

            JogoDAO.prototype.getAcoes = function(usuario, res) {
                // console.log('recuperar acoes');
                var date = new Date();
                var momento_atual = date.getTime();
                this._connection.collection('acao').find({usuario: usuario, acao_terminal_em: {$gt:momento_atual}}).toArray(function(err, result) {
                    // console.log(result);
                    res.render('pergaminhos', {acoes: result})
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        No caso, sempre que a contagem terminar ocorrerá uma remoção na quantidade da moeda.

    Aula 12 - Removendo ações:
        Vamos aprender a remover documentos dentro do banco de dados, MongoDB.
        Nada mais justo, depois que acontecer a ação, ser removido do banco de dados.
        No caso, vamos primeiro criar uma rota de revogar uma ação pelo jogo.js de routes.
            module.exports = function(application){
                application.get('/jogo', function(req, res){
                    // res.send('Bem vindo a sua app NodeJS!');
                    // res.render('jogo');
                    application.app.controllers.jogo.jogo(application, req, res);
                });

                application.get('/sair', function(req, res){
                    application.app.controllers.jogo.sair(application, req, res);
                });

                application.get('/suditos', function(req, res){
                    application.app.controllers.jogo.suditos(application, req, res);
                });

                application.get('/pergaminhos', function(req, res){
                    application.app.controllers.jogo.pergaminhos(application, req, res);
                });

                application.post('/ordenar_acao_sudito', function(req, res){
                    application.app.controllers.jogo.ordenar_acao_sudito(application, req, res);
                });

                application.get('/revogar_acao', function(req, res){
                    application.app.controllers.jogo.revogar_acao(application, req, res);
                });
            }
        Em seguida, vamos em jogo.js de controllers, e nela iremos definir a função revogar_acao e definir o que será exercido dentro dela.
            module.exports.jogo = function(application, req, res) {
                // if(req.session.autorizado) {
                //     res.render('jogo', {img_casa: req.session.casa});
                // } else {
                //     res.send('Usuário precisa fazer o login!');
                // }
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // var comando_invalido = 'N';

                // if(req.query.comando_invalido == 'S') {
                //     comando_invalido = 'S';
                // }

                var msg = '';

                if(req.query.msg != ''){
                    msg = req.query.msg;
                }

                // console.log(comando_invalido);

                var usuario = req.session.usuario;
                var casa = req.session.casa;

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                // JogoDAO.iniciaJogo(res, usuario, casa, comando_invalido);
                JogoDAO.iniciaJogo(res, usuario, casa, msg);
                // res.render('jogo', {img_casa: req.session.casa});
            }

            module.exports.sair = function(application, req, res) {
                // res.send('sair');
                req.session.destroy( function(err){
                    res.render("index", {validacao: {}});
                });
            }

            module.exports.suditos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                res.render("aldeoes");
            }

            module.exports.pergaminhos = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }

                // recuperar as ações inseridas no banco de dados.
                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                var usuario = req.session.usuario;

                JogoDAO.getAcoes(usuario, res);

                // res.render("pergaminhos", {acoes: {}});
            }

            module.exports.ordenar_acao_sudito = function(application, req, res) {
                if(req.session.autorizado !== true) {
                    res.send('Usuário precisa fazer o login!');
                    return;
                }
                var dadosForm = req.body;

                req.assert('acao', 'Ação deve ser informada').notEmpty();
                req.assert('quantidade', 'Quantidade deve ser informada').notEmpty();

                var erros = req.validationErrors();

                // if(erros){
                //     res.redirect('jogo?comando_invalido=S');
                //     return;
                // }

                if(erros){
                    res.redirect('jogo?msg=A');
                    return;
                }

                // console.log(dadosForm);
                // res.send('tudo ok!');

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                dadosForm.usuario = req.session.usuario;
                JogoDAO.acao(dadosForm);

                // res.send('tudo ok!');
                res.redirect('jogo?msg=B');
            }

            module.exports.revogar_acao = function(application, req, res) {
                var url_query = req.query;
                // res.send(url_query);

                var connection = application.config.dbConnection;
                var JogoDAO = new application.app.models.jogoDAO(connection);

                var id = url_query.id_acao;
                JogoDAO.revogarAcao(id, res);
            }
        Agora, em pergaminhos.ejs, onde consta "revogar ordem", nela podemos passar a rota "revogar_acao" e nela passar um parâmetro da seguinte forma.
            <div id="pergaminhos">					
                <h3>Pergaminhos</h3>
                
                <ul>
                    <% for(var i = 0; i < acoes.length; i++) { %>
                        <%
                            var txt_acao = '';

                            switch(parseInt(acoes[i].acao)){
                                case 1: txt_acao = 'Aldeão(ões) coletando recursos'; break;
                                case 2: txt_acao = 'Enforcar Aldeões'; break;
                                case 3: txt_acao = 'aldeão(ões) em treinamento de história'; break;
                                case 4: txt_acao = 'aldeão(ões) em treinamento de magia'; break;
                            }

                            var date = new Date();
                            var momento_atual = date.getTime();

                            var segundos_restantes = Math.round((acoes[i].acao_terminal_em - momento_atual) / 1000);
                        %>
                        <li>
                            <%=acoes[i].quantidade%> <%=txt_acao%>
                            - <small>restam <span class="tempo_restante"><%=segundos_restantes%></span> segundos 
                            - <a href="/revogar_acao?id_acao=<%=acoes[i]._id%>">revogar ordem</a></small>
                        </li>
                    <% } %>
                </ul>
            </div>
        Com o formato atual, vamos poder testar se está sendo enviado o id corretamente.
        Visto que está, então vamos agora usar o jogoDAO.js, para nela definir uma função que remova a tal ação.
            JogoDAO.prototype.revogarAcao = function(_id, res) {
                res.send(_id);
            }
        No caso, acima mostra que recebemos as instruções.
        No caso, agora, vamos remover.
            var ObjectID = require('mongodb').ObjectId;

            function JogoDAO(connection) {
                this._connection = connection();
            }

            JogoDAO.prototype.gerarParametros = function(usuario) {
                this._connection.collection('jogo').insertOne({
                    usuario: usuario,
                    moeda:15,
                    suditos:10,
                    temor: Math.floor(Math.random() * 1000),
                    sabedoria: Math.floor(Math.random() * 1000),
                    comercio: Math.floor(Math.random() * 1000),
                    magia: Math.floor(Math.random() * 1000)
                });
            }

            JogoDAO.prototype.iniciaJogo = function(res, usuario, casa, msg) {
                // console.log('Iniciar os parâmetros do jogo');

                this._connection.collection('jogo').find({usuario: usuario}).toArray(function(err, result){
                    // console.log(result[0]);
                    // res.render('jogo', {img_casa: casa, jogo: result[0], comando_invalido: comando_invalido});
                    res.render('jogo', {img_casa: casa, jogo: result[0], msg: msg});
                });
            }

            JogoDAO.prototype.acao = function(acao) {
                // console.log(acao);
                var date = new Date();

                var tempo = null;

                switch(parseInt(acao.acao)) {
                    case 1: tempo = 1*60*60000; break;
                    case 2: tempo = 2*60*60000; break;
                    case 3: tempo = 5*60*60000; break;
                    case 4: tempo = 5*60*60000; break;
                }

                acao.acao_terminal_em = date.getTime() + tempo;
                this._connection.collection('acao').insertOne(acao);

                var moedas = null;

                switch(parseInt(acao.acao)) {
                    case 1: moedas = -2 * parseInt(acao.quantidade); break;
                    case 2: moedas = -3 * parseInt(acao.quantidade); break;
                    case 3: moedas = -1 * parseInt(acao.quantidade); break;
                    case 4: moedas = -1 * parseInt(acao.quantidade); break;
                }

                this._connection.collection('jogo').updateMany({ usuario: acao.usuario }, { $inc: {moeda: moedas} });
            }

            JogoDAO.prototype.getAcoes = function(usuario, res) {
                // console.log('recuperar acoes');
                var date = new Date();
                var momento_atual = date.getTime();
                this._connection.collection('acao').find({usuario: usuario, acao_terminal_em: {$gt:momento_atual}}).toArray(function(err, result) {
                    // console.log(result);
                    res.render('pergaminhos', {acoes: result})
                });
            }

            JogoDAO.prototype.revogarAcao = function(_id, res) {
                // res.send(_id);
                this._connection.collection('acao').deleteOne({_id: ObjectID(_id)}, function(err, result){
                    res.redirect("jogo?msg=D");
                });
            }

            module.exports = function(){
                return JogoDAO;
            }
        Além disso, precisamos informar isso no jogo.ejs a remoção da ação.
            <% if(msg == 'D') {%>
				<div class="alert alert-info" id="msg">
					<strong>Senhor, sua ordem foi revogda!</strong>
				</div>
			<%} %>

    Aula 13 - Considerações finais:

    Aula 14 - Opcional - Download dos arquivos MMORPG GOT:
        Opcional - Download dos arquivos MMORPG GOT
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto MMORPG GOT no estado em que se encontram na aula anterior.

        Bons estudos ;)

    Aula 15 - Opcional - Atividades práticas:
        Opcional - Atividades práticas
        Que tal praticar?

        Baixe a relação de atividades em anexo e pratique seus conhecimentos!

        Boa sorte.
    
    OBS: Formas de fechar a conexão com o banco de dados, MongoDB: https://www.mongodb.com/community/forums/t/mongoclient-nodejs-open-close-connection-events/15042

Seção 18 - Criptografia de dados com Crypto:
    Aula 1 - Introdução a criptografia de dados:
        Criptografias Unidirecionais:
            -MD5: 
                https://www.devmedia.com.br/criptografia-md5/2944
                https://www.avast.com/pt-br/c-md5-hashing-algorithm
                https://pt.wikipedia.org/wiki/MD5
                https://pt.stackoverflow.com/questions/113378/usar-md5-%C3%A9-a-maneira-mais-segura-de-se-criptografar-senhas-no-php
            -SHA1:
                https://nstecnologia.com.br/blog/hash-sha1/
                https://calculareconverter.com.br/sha1-ecrypt-e-decrypt/
                https://pt.stackoverflow.com/questions/104713/como-descriptografar-md5-e-sha1
        Criptografia Bidirecional:
            -Base64:
                https://www.4devs.com.br/codificar_decodificar_base64
                https://pt.wikipedia.org/wiki/Base64
                https://developer.mozilla.org/pt-BR/docs/Glossary/Base64

    Aula 2 - NPM - Instalando o Crypto:
        Vamos instalar o módulo Crypto com npm no projeto mmorpg_got.
            npm install crypto --save

    Aula 3 - Criptografando senhas de usuários com MD5:
        Vamos agora usar o crypto.
        No caso, dentro do crypto já esta o MD5 que é o método de criptografia que iremos utilizar.
        No caso, vamos realizar a tal implementação para o arquivo UsuariosDAO.js de models, nas funções inserirUsuario e autenticar.
            var crypto = require('crypto');

            function UsuariosDAO(connection) {
                // console.log('Mostrar conexão antes: ', connection);
                this._connection = connection();
                // console.log('Mostrar conexão depois: ', this._connection);
            }

            UsuariosDAO.prototype.inserirUsuario = function(usuario) {
                // console.log(usuario);
                // console.log(usuario.senha);
                // insert(usuario);
                // this._connection.open( function(err, mongoclient){
                //     mongoclient.collection('usuarios', function(err, collection){
                //         collection.insert(usuario);
                //     });
                // } );
                var senha_criptografada = crypto.createHash("md5").update(usuario.senha).digest("hex");
                usuario.senha = senha_criptografada;
                // console.log(senha_criptografada);

                this._connection.collection('usuarios').insertOne(usuario);
            }

            UsuariosDAO.prototype.autenticar = function(usuario, req, res) {
                // console.log(usuario);
                // this._connection.collection('usuarios').find({usuario: {$eq: usuario.usuario}, senha: {$eq: usuario.senha}});
                var senha_criptografada = crypto.createHash("md5").update(usuario.senha).digest("hex");
                usuario.senha = senha_criptografada;
                this._connection.collection('usuarios').find(usuario).toArray(function(err, result){
                    console.log(result);
                    if(result[0] != undefined) {
                        // Lembra quando colocamos o middleware express-session em server.js?
                        req.session.autorizado = true;

                        req.session.usuario = result[0].usuario;
                        req.session.casa = result[0].casa;
                    }

                    if(req.session.autorizado) {
                        // res.send('Usuário foi encontrado no banco de dados!');
                        res.redirect("jogo");
                    } else {
                        // res.send('Usuário não existe no banco de dados!');
                        res.render("index", {validacao: {}});
                    }
                });
                // this._connection.close();
            }

            module.exports = function(){
                return UsuariosDAO;
            }
        Agora, todas as senhas estão guardadas de forma criptografadas.

Seção 19 - Content Negotiation e Status Code:
    Aula 1 - O que é Content Negotiation:
        Leituras para entender o que é Content Negotiation:
            https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Content_negotiation
            https://en.wikipedia.org/wiki/Content_negotiation
            https://learn.microsoft.com/pt-br/aspnet/web-api/overview/formats-and-model-binding/content-negotiation
            https://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html

    Aula 2 - Download das aplicações Server/Client:
        Download das aplicações Server/Client
        Utilize o link disponibilizado como recurso dessa aula para fazer o download das aplicações Server/Client que serão utilizadas neste módulo.

        Bons estudos ;)

    Aula 3 - Accept: Negociando o conteúdo de recebimento:
        Vamos pegar o diretório que fizemos o download na aula anterior, apps_client_servidor.
        Disso, vamos realizar uma nova implementação acima desse diretório.
        No caso, ao descompactarmos esse arquivo zipado, será liberado uma pasta apps.
        Focaremos agora nessa pasta para o novo projeto.
        No caso, no diretório cliente que está vazio, vamos criar uma aplicação frontEnd para Android.
        Mas, antes disso, vamos primeiro rodar o que consta dentro do diretóro servidor para verificar se está tudo ok.
        Para isso, no app.js que está no servidor, como consta a porta padrão do localhost, nela iremos subir para verificar se está tudo correto na aplicação.
        Assim, pelo terminal, acessando a pasta servidor, rodemos o nodemon.
        Daí, acessando pelo navegador, localhost, aparecerá a msg de boas vindas.
        Agora, no diretório cliente, vamos criar um arquivo android.js
            var http = require('http');

            http.get('http://localhost/', function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    console.log(' '+pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        Agora, vamos rodar esse arquivo android.js para verificarmos o que está acontecendo.
        No caso, o http que demos o require acima ele consegue verificar os três momentos, quanto a página está carregando, termina de carregar e quano der algum erro.
        Se tudo ocorrer bem, quando rodarmos o node e o nome do arquivo android.js acessado o diretorio cliente, irá aparecer a msg que consta no localhost (precisa que o servidor esteja rodando com o nodemon).
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                Bem vindo a sua app NodeJS!

        Daí, se fizermos a seguinte alteração, vemos que aparecerá uma msg ilegível.
            var http = require('http');

            http.get('http://localhost', function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    console.log(pedaco);
                });

                // res.on('end', function(){
                //     // Possibilita em tomar alguma ação após a página terminar de carregar
                // });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        Ao rodarmos, novamente, node android.js, temos que.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                <Buffer 42 65 6d 20 76 69 6e 64 6f 20 61 20 73 75 61 20 61 70 70 20 4e 6f 64 65 4a 53 21>
        Podemos melhorar isso da seguinte forma.
            var http = require('http');

            var buffer_corpo_response = [];

            http.get('http://localhost', function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        Com isso, novamente, rodando node android.js a msg que é exibida em localhost será exibida.
        Agora, vamos realizar a seguinte alteração em JSON.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/'
            }

            var buffer_corpo_response = [];

            http.get(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        No caso, a forma acima é uma outra maneira de vc especificar qual porta e qual local está sendo utilizado para exibição.
        Ao rodarmos novamente, node android.js, iremos ter o mesmo resultado.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                headers: {
                    'Accept': 'text/html'
                }
            }

            var buffer_corpo_response = [];

            http.get(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        No caso, acrescentamos o headers acima, donde podemos verificar o que é devolvido pelo Headers ao visitarmos o console do navegador.
        Nela, no Accept, está especificando o text/html.
        Assim, rodando novamente node android.js, acima, teremos o mesmo retorno do texto de boas vindas.
        Agora, no mesmo Accept, realizamos a seguinte alteração.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                headers: {
                    'Accept': 'application/json'
                }
            }

            var buffer_corpo_response = [];

            http.get(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });
        Entretanto, não vai adiantar de nada realizar apenas essa alteração.
        Vamos precisar tbm colocar mais algumas implementações no index.js de routes do servidor app, onde é dado o res.send com a msg de boas vindas.
            module.exports = function(application){
                application.get('/', function(req, res){

                    res.format({
                        html: function() {
                            res.send('Bem vindo a sua app NodeJS!');
                        },

                        json: function() {
                            var retorno = {
                                body: 'Bem vindo a sua app NodeJS!'
                            }

                            res.json(retorno);
                        }
                    });
                    // res.send('Bem vindo a sua app NodeJS!');
                });
            }
        Ao rodarmos novamente node android.js, será exibido uma msg como seguinte.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                {"body":"Bem vindo a sua app NodeJS!"}
        No caso, com a configuração como foi feito no index.js acima, no Accept, do android.js se ficarmos alterando entre 'text/html' e 'application/json', repsectivamente, será exibido a msg em forma de texto e uma em forma de json.
        Esse formato de recepção diversa, pode valer para banco de dados, MongoDB, por exemplo, ou para aplicativos Android.

    Aula 4 - Content-type: Negociando o conteúdo de envio:
        Vamos agora mudar o método que está sendo executado em android.js.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                headers: {
                    'Accept': 'application/json'
                }
            }

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            req.end();
        Ao rodarmos novamente, node android.js, veremos que nada se alterou, continua funcionando tudo corramente.
        Mas a diferença com o request e o get, é que a requisição via request, podemos versatilizar os tipos de requisições existents, get, post, etc...
        Como exemplo disso, vamos realizar a seguinte implementação em android.js.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                method: 'post',
                headers: {
                    'Accept': 'application/json'
                }
            }

            // Content-type
            var html = 'nome=Leonardo';

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            req.write(html);
            req.end();
        Como foi requisitado o método post acima, então precisamos colocar esse método tbm no index.js de routes de servidor.
            module.exports = function(application){
                application.get('/', function(req, res){

                    res.format({
                        html: function() {
                            res.send('Bem vindo a sua app NodeJS!');
                        },

                        json: function() {
                            var retorno = {
                                body: 'Bem vindo a sua app NodeJS!'
                            }

                            res.json(retorno);
                        }
                    });
                    // res.send('Bem vindo a sua app NodeJS!');
                });

                application.post('/', function(req, res){
                    res.send('teste');
                });
            }
        No caso, ao rodarmos novamente o node android.js, vamos ver que msg teste foi exibida provando que de fato a requisição post definida foi executado.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                teste
        Agora, precisamos receber a msg que foi colocado na variavel html.
        Para isso, será preciso usar o bodu-parse, que já está cpnfigurado no server.js.
        Então, no index.js de routes, vamos poder realizar o seguinte.
            module.exports = function(application){
                application.get('/', function(req, res){

                    res.format({
                        html: function() {
                            res.send('Bem vindo a sua app NodeJS!');
                        },

                        json: function() {
                            var retorno = {
                                body: 'Bem vindo a sua app NodeJS!'
                            }

                            res.json(retorno);
                        }
                    });
                    // res.send('Bem vindo a sua app NodeJS!');
                });

                application.post('/', function(req, res){
                    // res.send('teste');
                    var dados = req.body;
                    res.send(dados);
                });
            }
        Se rodarmos novamente, node android.js será retornado o seguinte.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                {}
        Se for exibido essa msg, significa que deu certo.
        Agora, precisamos definir o content-type dentro de headers, para conseguirmos exibir a msg que está dentro da variável html.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                method: 'post',
                headers: {
                    'Accept': 'application/json',
                    'Content-type': 'application/x-www-form-urlencoded'
                }
            }

            // Content-type
            var html = 'nome=Leonardo'; // x-www-form-urlencoded

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            req.write(html);
            req.end();
        Ao rodarmos novamente, node android.js, será exibido em formato json o que definimos dentro da variável html.
        Podemos, tbm, realizar a mesma coisa da seguinte forma, que seria dando uma variável json no formato json e converter essa variável por uma string e susbstituindo no write.
        Além disso, com o Content-type, mudado para application/json.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/',
                method: 'post',
                headers: {
                    'Accept': 'application/json',
                    'Content-type': 'application/json'
                }
            }

            // Content-type
            var html = 'nome=Leonardo'; // x-www-form-urlencoded
            var json = { nome: 'Leonardo'};
            var string_json = JSON.stringify(json);

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            // req.write(html);
            req.write(string_json);
            req.end();
        Assim, ao rodarmos novamente, node android.js, será exibido um json vazio.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                {}
        Motivo disso, deve-se ao fato de que o body-parser não suportar o formato json, o que está configurado no server.js.
        Para isso, vamos precisar configurar no server.js, um body-parser que admite o formato json.
            /* configurar o middleware body-parser */
            app.use(bodyParser.urlencoded({extended: true}));
            app.use(bodyParser.json());
        Assim, rodando novamente, node android.js, vamos ver que desta vez é exibido o json com o conteúdo definido dentro.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                {"nome":"Leonardo"}


    Aula 5 - Opcional - Download dos arquivos do projeto Server/Client:
        Opcional - Download dos arquivos do projeto Server/Client
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto Server/Client no estado em que se encontram na aula anterior.

        Bons estudos ;)

    Aula 6 - Introdução aos Códigos de status (Status Code):
        Leitura para o conteúdo:
            https://moz.com/learn/seo/http-status-codes#:~:text=An%20HTTP%20status%20code%20is,code%3A%20the%20HTTP%20status%20code.
            https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
            https://www.devmedia.com.br/http-status-code/41222
            https://www.hostinger.com.br/tutoriais/o-que-e-http-error-e-principais-codigos-http#:~:text=Status%2Dcode%20s%C3%A3o%20os%20tr%C3%AAs,para%20melhor%20compreens%C3%A3o%20dos%20usu%C3%A1rios.
            https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status

    Aula 7 - Criando middlewares para páginas personalizadas de erro (status code):
        Nesta aula, vamos aprender a mexer em status.
        Lembrando que o status code, pode ser aplicados tanto do lado de servidor quanto do cliente.
        Para isso, vamos configurar o seguinte no android.js, para praticarmos o erro 404, page not Found.
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/teste',
                method: 'get',
                headers: {
                    'Accept': 'application/json',
                    'Content-type': 'application/json'
                }
            }

            // Content-type
            // var html = 'nome=Leonardo'; // x-www-form-urlencoded
            // var json = { nome: 'Leonardo'};
            // var string_json = JSON.stringify(json);

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            // req.write(html);
            // req.write(string_json);
            req.end();
        Assim, executando o script, node android.js, vamos ter o seguinte.]
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                Cannot GET /teste
        Analisando isso no broswer, será exibido o status 404, ao acessarmos o console.
        O mesmo status, podemos verificar pelo lado do servidor colocando um console Log
            var http = require('http');

            var opcoes = {
                hostname: 'localhost',
                port: 80,
                path: '/teste',
                method: 'get',
                headers: {
                    'Accept': 'application/json',
                    'Content-type': 'application/json'
                }
            }

            // Content-type
            // var html = 'nome=Leonardo'; // x-www-form-urlencoded
            // var json = { nome: 'Leonardo'};
            // var string_json = JSON.stringify(json);

            var buffer_corpo_response = [];

            // http.get(opcoes, function(res){
            //     res.on('data', function(pedaco){
            //         // serve para exibir as informações
            //         // console.log(' ' + pedaco);
            //         // console.log(pedaco);
            //         buffer_corpo_response.push(pedaco);
            //     });

            //     res.on('end', function(){
            //         // Possibilita em tomar alguma ação após a página terminar de carregar
            //         var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
            //         console.log(corpo_responde);
            //     });

            //     // res.on('error', function(){
            //     //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
            //     // });
            // });

            var req = http.request(opcoes, function(res){
                res.on('data', function(pedaco){
                    // serve para exibir as informações
                    // console.log(' ' + pedaco);
                    // console.log(pedaco);
                    buffer_corpo_response.push(pedaco);
                });

                res.on('end', function(){
                    // Possibilita em tomar alguma ação após a página terminar de carregar
                    var corpo_responde = Buffer.concat(buffer_corpo_response).toString();
                    console.log(corpo_responde);
                    console.log(res.statusCode);
                });

                // res.on('error', function(){
                //     // Exibi algum erro, caso a página não carregue ou carreue de forma mau sucedida.
                // });
            });

            // req.write(html);
            // req.write(string_json);
            req.end();
        Assim, rodando novamente o script, node android.js, será exibido a seguinte infomação.
            root@leonardo-Dell-G15-5520:/home/leonardo/Documentos/estudos/apps/cliente# node android.js
                Cannot GET /teste

                404
        Para podermos tratar os status, vamos usar o express, para isso.
        Vamos precisar configurar um middleware para isso no arquivo server.js.
        Lembrando que a posição em que é configurado o middleware é muito importante.
            // middleware que configura páginas de status
            app.use(function(req, res, next){

                res.status(404).send('Página não encontrado');

                next();
            });
        Abaixo do consing.
        Ao acessarmos o localhost/teste, agora, pelo navegador, tal mensagem que está definido no send será exibido, indicando que conseguimos dar as devidas tratativas para esse status 404.
        No caso, isso nos possibilita realizar em tratar os erros, por exemplo, criando uma pagina que aprensente tal erro.
        No caso, na views, podemos criar um diretório erros, e dentro dela criar um arquivo 404.ejs e dentro dela definirmos o seguinte.
            A página não foi encontrada, verifique a URL informada.
        Daí, no server onde configuramos o middleware, em vez de send, podemos renderizar essa pagina.
            // middleware que configura páginas de status
            app.use(function(req, res, next){

                // res.status(404).send('Página não encontrado');
                res.status(404).render('erros/404');

                next();
            });
        Ao acessarmos novamente a página, localhot/teste, será exibido o conteúdo dentro de 404.ejs.
        Podemos tbm tratar os erros internos desse lugar, como quando renderizamos algo que não existe, então será exibido o status 500.
        Vamos configurar esse erro, novamente, pelo middleware no server.js.
            // middleware que configura páginas de status
            app.use(function(req, res, next){

                // res.status(404).send('Página não encontrado');
                res.status(404).render('erros/404');

                next();
            });

            // middleware que configura msg de erros internos
            app.use(function(err, req, res, next){

                // res.status(404).send('Página não encontrado');
                res.status(500).render('erros/500');

                next();
            });
        Além disso, em erros, criarmos mais um arquivo 500.ejs.
            Desculpe, houve um erro interno na aplicação.
        Assim, no index.js de routes, se renderizarmos algo que não existe, essa página será exibido.
        Graças ao next(), em todos os casos o processamento continua, mesmo ocorrendo o erro.

Seção 20 - Projeto prático - API RESTful e Instagram Clone WEB:
    Aula 1 - O que é uma API?:
        Leituras para esse conteúdo: (Apenas Leitura!)
            https://www.techtudo.com.br/listas/2020/06/o-que-e-api-e-para-que-serve-cinco-perguntas-e-respostas.ghtml
            https://aws.amazon.com/pt/what-is/api/
            https://www.sydle.com/br/blog/api-6214f68876950e47761c40e7/
            https://www.luiztools.com.br/post/como-criar-uma-web-api-com-nodejs/

    Aula 2 - O que são URIs, URLs e URNs?:
        Leituras para esse conteúdo:
            https://techenter.com.br/o-que-sao-uri-url-e-urn/
            https://forum.casadodesenvolvedor.com.br/topic/44416-o-que-s%C3%A3o-url-uri-e-urn-%F0%9F%A4%94/
            https://igluonline.com/qual-diferenca-entre-url-uri-e-urn/
            https://pt.wikipedia.org/wiki/URI

    Aula 3 - Introdução ao REST:
        Leituras para esse conteúdo:
            https://pt.wikipedia.org/wiki/REST
            https://coodesh.com/blog/dicionario/o-que-e-rest/
            https://www.astera.com/pt/tipo/blog/defini%C3%A7%C3%A3o-de-api/
            https://www.alura.com.br/artigos/rest-conceito-e-fundamentos

    Aula 4 - Postman (Rest Client): Instalação e primeiros passos:
        Vamos instalar o Postman, que será uma software que permitirá experimentar as apis.
        Vamos instalar o postman a partir do webstore.
        No caso, nas extensões do google Chrome.
        https://chrome.google.com/webstore/category/extensions?hl=pt-PT
        Em seguida realiza o sign up cadastrando algum usuário seu ou com a conta google.
        Para usuário Linux pode-se realizar um download do postman para a própria máquina baixando o arquivo, e em seguida rodar o comando "sudo snap install postman".

    Aula 5 - Download dos arquivos iniciais da API:
        Download dos arquivos iniciais da API
        Utilize o link disponibilizado como recurso dessa aula para fazer o download do package.json, arquivo necessário para dar início a construção da nossa API RESTFull.

        Bons estudos ;)

    Aula 6 - Iniciando o projeto da API através do package.json e criando o server:
        Vamos dar início ao projeto da API através do package.json que foi baixado acima.
        Partiremos de um package.json pré-configurado e configurarmos a aplicação web.
        Em seguida, vamos criar um diretório chamado "instagram_clone" e dentro dela criar um outro diretório api e dentro desse diretório colocamos o arquivo package.json.
        Daí, iremos realizar as aplicações dentro dela.
        Note que, dentro de package.json, já estão as dependências configuradas nela, donde é o que indica o que é necessário para esse projeto.
        Para instalarmos tais dependências, bastaria rodarmos o comando "npm install" ou "npm i" no diretório projeto, que automaticamente será lido as denpendências necessárias para o package.json e instaladas.
        No caso, pelo terminal, abrindo até o diretório api desse novo projeto, dentro dela, basta rodar o comando "npm install".
        Após isso, note que, foi baixado, dentro do diretório api, a pasta node_modules, donde dentro dela estão as dependências exigidas pelo package.json.
        Agora, em seguida vamos criar um arquivo server.js dentro do diretório api.
        Nesse arquivo, vamos colocar os seguintes.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express'),
                bodyParser = require('body-parser'),
                mongodb = require('mongodb');

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);
        Assim, ao rodarmos o nodemon server, se for exibido a informação no console log pelo terminal, significa que a aplicação deu certo.

    Aula 7 - Dando um "olá" para o Postman:
        Vamos configurar lá dentro da api, uma olá para rodarmos no postman via GET.
        Importante fazer um beve sumário:
            - POST: criação
            - GET: Consulta
            - PUT: Atualizar
            - DELETE: Remover
        Configuremos o arquivo server.js adicionando uma rota dentro dela.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express'),
                bodyParser = require('body-parser'),
                mongodb = require('mongodb');

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);

            app.get('/', function(req, res){
                res.send({msg: 'Hello WounderWorld!'});
            });
        Assim, vamos abrir o Postman e nela rodar o seguinte link, localhost:8080, com o método GET.
        Ao realizarmos isso, deverá ser exibido o objeto json que definimos acima.

    Aula 8 - Method Post: Incluindo documentos no MongoDB:
        No caso, agora, vamos criar um objet para post para incluir docuentos no MongoDB.
        Para isso, primeiro, vamos precisar configurar a conexão com o mongodb.
        Mas, antes disso, vamos deixar estabelecido, via express, como será feito o post pelo server.js.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express'),
                bodyParser = require('body-parser'),
                mongodb = require('mongodb');

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);

            app.get('/', function(req, res){
                res.send({msg: 'Hello WounderWorld!'});
            });

            app.post('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
            });
        Em seguida, usar o método POST, do Postman, e nela rodar o link, localhost:8080/api, e verifcarmos se está sendo rodado corretamente analisando o status que é retornado.
        Se aparecer uma msg 200 OK com um objeto vazio, então significa que o deu certo o post.
        Em seguida, só falta linkar esse método post definido no server.js, via express, com a conexão mongoDB para inserir algum documento dentro desse banco de dados.
        Mas, antes, primeiro, no Postman, vamos configurar o formato que será enviado, que é usando o urlencoded.
        No caso, em Postman, onde aparece a aba de menu Params, Authorization, Headers, Body, Pre-request Script, Tests e Settings, vamos clicar no Body.
        Em seguida, selecionamos a alernativa "x-www-form-urlencoded".
        Assim, vamos definir duas keys, titulo e url_imagem, respectivamente, vamos colocar nos values um "oi" e "oi.png".
        Assim, com o método POST ainda selecionado e com o mesmo link rodado da última vez, rodando novamente irá aparecer, desta vez, um objeto json cujos elementos são os titulos e url_imagem que definimos nos passos acima.
        Ou seja, isso indica que no lado do servidor tais informações já estão sendo obtidas.
        O que falta agora, é enviar tais msgs para o MongoDB.]
        Como foi visto antes no projeto mmorpg_got a forma para estabelecer a conexão com o mongoDB havia mudado e os comandos para realizar algum tipo de requisição no banco de dados tbm havia mudado.
        Logo, para conseguir dar continuidade nesse curso, seria necessário verificar a forma atualizada para estabelecer conexão com o MongoDB, como foi feito no projeto mmorpg_got.
        Estou tendo dificuldade para realizar isso, então seria necessário dar uma olhada no curso do mongoDB ou estudar pelo github que eu peguei acima de mongoDB e nodejs e ver como posso resolver esse problema primeiro.
        Para não perder o andamento do curso, continuar realizado as anotações.
        CAso eu consiga consigurar o mongoDB no server.js e conectar com o banco de dados MongoDB, iremos rodar no Postman, usando o método POST, com o localhost:8080/api, o seguinte que está no arquivo server.js
            app.post('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').insertOne(dados);
            });
        No caso, onde está escrito main(), é uma função que estabelece a conexão com o banco de dados MongoDB para possibilitar a inserção de um documento.

    Aula 9 - Method Get: Recuperando documentos do MongoDB:
        Nessa aula vamos testar o método GET no Postman colocando a seguinte requisição de get no server.js
            // GET (read)
            app.get('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find().toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.json(results);
                    }
                });
            });
        Daí, vc preciaria ir no Postman e colocar o método GET para o link localhost:8080/api que será lido o que foi solicitado aqui.

    Aula 10 - Method Get by ID: Recuperando documento por ID no MongoDB:
        Agora, vamos usar um método GET colocando parâmetros para filtrar o tipo de consulta no banco de dados usando o Postman.
        Para isso, no arquivo server.js, vamos realizar a seguinte implementação.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express');
            var bodyParser = require('body-parser');
            var objectId = require('mongodb').ObjectId;

            const { MongoClient } = require('mongodb');
            const url = 'mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1';
            const client = new MongoClient(url);
            const dbName = 'instagram';

            function main() {
                client.connect();
                console.log('Conectado com sucesso no banco de dados MongoDB Community Edition!');
                const db = client.db(dbName);
            
                return db;
            }

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);

            app.get('/', function(req, res){
                res.send({msg: 'Hello WounderWorld!'});
            });

            // POST (create)
            app.post('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').insertOne(dados);
            });

            // GET (read)
            app.get('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find().toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.json(results);
                    }
                });
            });

            // GET by ID (read)
            app.get('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find({_id : objectId(req.params.id) }).toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.json(results);
                    }
                });
            });
        Será a forma como vamos consultar.
        Assim, no Postman, ainda com o método GET ativo, vamos colocar o link localhost:8080/api/(algum parâmetro _id) que isso refinará a busca exatamente ao parâmetro que foi colocado.


    Aula 11 - Method Put by ID: Atualizando documentos por ID no MongoDB:
        Agora, vamos usar o método PUT do Postman, mas atualizarmos algum dado via busca id, parecido com o que foi feito acima no get by id.
        Para isso, vamos precisar realizar a seguinte implementação no server.js.
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').update(
                    { _id : objectId(req.params.id) },
                    { $set : { titulo: req.body.titulo }},
                    {},
                    function(err, records) {
                        if(err) {
                            res.json(err);
                        } else {
                            res.json(records);
                        }

                        // colocar o comando que fecha a conexão com o banco de dados.
                    }
                );
            });
        Assim, no Postman, vamos colocar o método PUT, em seguida no Body e selecionando o x-www-form-urlencoded, vamos colocar no key, título, e no value, Titulo atualizado via PUT.
        Assim, rodando o send, será atualizado o título para o _id que foi colocado em localhost:8080/api/_id.

    Aula 12 - Method Delete by ID: Removendo documentos por ID no MongoDB:
        Vamos, agora, deletar as informações do banco de dados, MongoDB, via método DELETE pelo Postman informando o id para ela.
        Para isso, no arquivo server.js, vamos realizar a seguinte implementação.
            // DELETE by ID (remove)
            app.delete('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').deleteOne({ _id : objectId(req.params.id) }, function(err, records) {
                    if(err) {
                        res.json(err);
                    } else {
                        res.json(records);
                    }

                    // colocar o comando que fecha a conexão com o banco de dados.
                });
            });
        Assim, no Postman vamos colocar o método DELETE e nela rodar o link localhost:8080/api/(algum id).
        Vamos ver que no banco de dados foi deletado tal informação que pedimos.
        Uma boa prática sempre que realizarmos alguma alteração seria validar a tal operação.
        Uma via aqui no curso, para isso, seria usando o express-validator, para que qualquer operação POST, GET, PUT e DELETE, for realizado, sempre perguntarmos se tem certeza que queremos realizar a tal operação.

    Aula 13 - Ajustando o código de status do response com base no Verbo HTTP/URI:
        No caso, vamos ajustar os status para cada tipo de operação que estivermos executando, de forma que tais informações sirva de ajuda para mim mesmo em verificar o que está ou não está sendo feito de forma bem feita.
        Podemos, implementar isso, por exemplo, no server.js da seguinte forma usando o GET by Id como exemplo.
            // GET by ID (read)
            app.get('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find({_id : objectId(req.params.id) }).toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.status(500).json(results);
                    }
                });
            });
        Assim, ao rodarmos no Postman o método GET com o link localhost:8080/api/(algum _id), será retornado o status 500, se tiver dado certo, ainda na mesma tela do Postman.
        E podemos colocar tais números de forma personalizadas dando relevância à lógica interna da operação.
            // GET by ID (read)
            app.get('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find({_id : objectId(req.params.id) }).toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.status(200).json(results);
                    }
                });
            });

    Aula 14 - Opcional - Download dos arquivos da API:
        Opcional - Download dos arquivos da API
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto API no estado em que se encontram na aula anterior.

        Bons estudos ;)

    Aula 15 - Download dos arquivos iniciais do Instagram Clone WEB:
        Download dos arquivos iniciais do Instagram Clone WEB
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos iniciais do cliente web Instagram Clone.

        Bons estudos ;)

    Aula 16 - Breve explicação sobre a aplicação e seus recursos:
        Descompactando o arquivo cliente_web_instagram_clone, vamos agora direcionar as nossas aplicações para o lado de frontEnd.
        Assim, pegamos essa pasta descompactada e colocamos dentro do instagram_clone.
        No caso, essa pasta já vem com as configurações básicas prontas.
        Vamos inclusive rodar pelo nodemon e verificar se conseguimos rodar isso pelo navegador colocando o localhos.
        Deverá aparecer exatamente a tela de login para acessar o instagram.
        No caso, teremos duas páginas, uma de login e uma de home, localhost/home.

    Aula 17 - Incluindo publicações - parte 1:
        O objetivo dessa aula, seria implementar uma publicação, mas usando o serviço da api.
        No caso, em padrao.ejs que está no diretório views do diretório app da pasta client_web_instagram_clone, vamos realizar a seguinte modificação no script usando o jquery.
            <script>
                $(document).ready(function(){

                    $('#btn_incluir').click(function(){
                        $('#container_timeline').hide();
                        $('#container_form').show();
                    });

                    $('#btn-cancelar-publicacao').click(function(){
                        $('#container_timeline').show();
                        $('#container_form').hide();
                        return false;
                    });

                    $('#btn-publicar').click(function(){
                        // criar um formData
                        var formData = new FormData(); // chave=valor

                        var arquivo = document.getElementById("arquivo").files[0];
                        var titulo = document.getElementById("titulo").value;

                        formData.append("arquivo", arquivo);
                        formData.append("titulo", titulo);

                        // criar xmlhttprequest
                        var xhr = new XMLHttpRequest();

                        // verificar as mudanças de estado
                        xhr.onreadystatechange = function() {
                            if(xhr.readyState == 4) {
                                var resposta = xhr.responseText;
                                document.getElementById('mensagem').innerHTML = resposta;
                            }
                        }

                        // fazer o envio do nosso request
                        xhr.open("POST", "http://localhost:8080/api");
                        xhr.send(formData);
                    });

                });
            </script>
        Em seguida, vamos fazer a seguite publicação agora.
        No caso, visitando localhost/home, nela iremos colocar uma imagem e um título clicando no icone da câmera.
        Entretanto será exibida a msg de erro como abaixo.
            XMLHttpRequest cannot load

    Aula 18 - Incluindo publicações - parte 2:
        O objetivo é corrigir esse problema de XMLHttpRequest cannot load.
        Logo, no server.js de api, em app.post, vamos colocar o seguinte.
            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                var dados = req.body;

                console.log(dados);

                res.send(dados);
                // main().collection('postagens').insertOne(dados);
            });
        Por hora, para verificar se está sendo recebido de forma bem sucedida.
        Se foi retornado um json vazio, então, por hora, a aplicação está indo bem.
        O que aconteceu foi que agora temos um novo formato de enctype que está sendo recebido.
        No caso, em vez de application/x-www-form-urlencoded, está sendo multipart/form-data, donde em server.js, não está tendo estratura o suficiente ainda para receber esse tipo de formato de arquivo.
        Vamos precisar instalar isso via npm, o connect-multiparty, que é um middleware, e depois resolver o problema.

    Aula 19 - NPM - instalando o Connect-Multiparty:
        Vamos realizar a instalação do connect-multiparty.
            npm install connect-multiparty --save
        Agora, vamos configurar como um middleware na nossa aplicação.
        Então, no arquivo server.js da api, vamos realizar o seguinte.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express');
            var bodyParser = require('body-parser');
            var objectId = require('mongodb').ObjectId;
            var multiparty = require('connect-multiparty');

            const { MongoClient } = require('mongodb');
            const url = 'mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1';
            const client = new MongoClient(url);
            const dbName = 'instagram';

            function main() {
                client.connect();
                console.log('Conectado com sucesso no banco de dados MongoDB Community Edition!');
                const db = client.db(dbName);
            
                return db;
            }

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());
            app.use(multiparty());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);

            app.get('/', function(req, res){
                res.send({msg: 'Hello WounderWorld!'});
            });

            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                var dados = req.body;

                console.log(dados);

                res.send(dados);
                // main().collection('postagens').insertOne(dados);
            });

            // GET (read)
            app.get('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find().toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.json(results);
                    }
                });
            });

            // GET by ID (read)
            app.get('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find({_id : objectId(req.params.id) }).toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.status(200).json(results);
                    }
                });
            });

            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').update(
                    { _id : objectId(req.params.id) },
                    { $set : { titulo: req.body.titulo }},
                    {},
                    function(err, records) {
                        if(err) {
                            res.json(err);
                        } else {
                            res.json(records);
                        }

                        // colocar o comando que fecha a conexão com o banco de dados.
                    }
                );
            });

            // DELETE by ID (remove)
            app.delete('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').deleteOne({ _id : objectId(req.params.id) }, function(err, records) {
                    if(err) {
                        res.json(err);
                    } else {
                        res.json(records);
                    }

                    // colocar o comando que fecha a conexão com o banco de dados.
                });
            });
        Agora, vamos rodar novamente para verificarmos se está sendo trago o que precisa quando clicamos no botão publicar.
        Assim, desta vez foi enviado a mensagem com o título.
        Agora, só falta  configurarmos o upload da imagem.

    Aula 20 - Incluindo publicações - parte 3:
        Visto a instalação acima, agora, vamos configurar o upload da imagem, para que seja possível, por fim, conseguirmos enviar ao banco de dados tais publicações.
        Logo, no server.js, temos que analisar o seguinte.
            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                var dados = req.body;

                console.log(dados);

                console.log(req.files);

                res.send(dados);
                // main().collection('postagens').insertOne(dados);
            });
        No caso, o console log de req.files que colocamos acima, permite-nos verificar pelo terminal se está ou não recebendo a imagem na qual temos enviado.
            [nodemon] 2.0.20
            [nodemon] to restart at any time, enter `rs`
            [nodemon] watching path(s): *.*
            [nodemon] watching extensions: js,mjs,json
            [nodemon] starting `node server.js`
            Servidor HTTP esta escutando na porta 8080
            { titulo: 'Trabalho Tóxico' }
            {
            arquivo: {
                fieldName: 'arquivo',
                originalFilename: '323917347_460863916256077_3387055700615368140_n.jpg',
                path: '/tmp/2KDcPvMiQPR_DLrh2gpxjIjM.jpg',
                headers: {
                'content-disposition': 'form-data; name="arquivo"; filename="323917347_460863916256077_3387055700615368140_n.jpg"',
                'content-type': 'image/jpeg'
                },
                size: 63944,
                name: '323917347_460863916256077_3387055700615368140_n.jpg',
                type: 'image/jpeg'
            }
            }
        Foi exibido aqui a imagem que temos carregado.
        Note que, pelo path, que definimos, o arquivo ficou tem um diretório temporário, tmp. 
        No caso, o que precisaríamos realizar agora, é acessar esse diretório onde ficam os arquivos de forma temporária e carregar ela.
        Para isso, iremos usar um módulo que permite realizar isso chamado "fs" (file system).
        No caso, vamos fazer o require desse módulo em server.js.
            // Formato clássico
            // var express = require('express');
            // var bodyParser = require('body-parser');
            // var mongodb = require('mongodb');

            // Formato robusto
            var express = require('express');
            var bodyParser = require('body-parser');
            var objectId = require('mongodb').ObjectId;
            var multiparty = require('connect-multiparty');
            var fs = require('fs');

            const { MongoClient } = require('mongodb');
            const { json } = require('body-parser');
            const url = 'mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.1';
            const client = new MongoClient(url);
            const dbName = 'instagram';

            function main() {
                client.connect();
                console.log('Conectado com sucesso no banco de dados MongoDB Community Edition!');
                const db = client.db(dbName);
            
                return db;
            }

            var app = express();

            // body-parser como middleware
            app.use(bodyParser.urlencoded({ extended:true }));
            app.use(bodyParser.json());
            app.use(multiparty());

            var port = 8080;

            app.listen(port);

            console.log('Servidor HTTP esta escutando na porta ' + port);

            app.get('/', function(req, res){
                res.send({msg: 'Hello WounderWorld!'});
            });

            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                var dados = req.body;

                console.log(dados);

                console.log(req.files);

                res.send(dados);

                var path_origem = req.files.arquivo.path;
                var path_destino = './uploads/' + req.files.arquivo.originalFilename;

                fs.rename(path_origem, path_destino, function(err){
                    if(err){
                        res.status(500).json({error: err})
                        return;
                    }
                });
                // main().collection('postagens').insertOne(dados);
            });

            // GET (read)
            app.get('/api', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find().toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.json(results);
                    }
                });
            });

            // GET by ID (read)
            app.get('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').find({_id : objectId(req.params.id) }).toArray(function(err, results){
                    if(err){
                        res.json(err);
                    } else {
                        res.status(200).json(results);
                    }
                });
            });

            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').update(
                    { _id : objectId(req.params.id) },
                    { $set : { titulo: req.body.titulo }},
                    {},
                    function(err, records) {
                        if(err) {
                            res.json(err);
                        } else {
                            res.json(records);
                        }

                        // colocar o comando que fecha a conexão com o banco de dados.
                    }
                );
            });

            // DELETE by ID (remove)
            app.delete('/api/:id', function(req, res){
                var dados = req.body;

                res.send(dados);
                main().collection('postagens').deleteOne({ _id : objectId(req.params.id) }, function(err, records) {
                    if(err) {
                        res.json(err);
                    } else {
                        res.json(records);
                    }

                    // colocar o comando que fecha a conexão com o banco de dados.
                });
            });
        Daí, vamos criar mais um diretório dentro do api chamado uploads. Dentro dela, serão enviados as imagens que foram carregadas usando o fs.
        Feito as configurações acima, podemos testar se de fato as imagens que eu carreguei no localhost/home será enviado dentro desse diretório.
        Como, podemos ver, de fato, a imagem que carregamos foi enviado no uploads.
        Agora, falta configurarmos alguns no POST que definimos em server.js, visto que está sendo possível carregar a imagem.
            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                // var dados = req.body;

                // console.log(dados);

                // console.log(req.files);

                // res.send(dados);

                var path_origem = req.files.arquivo.path;
                var path_destino = './uploads/' + req.files.arquivo.originalFilename;

                var url_imagem = req.files.arquivo.originalFilename;

                fs.rename(path_origem, path_destino, function(err){
                    if(err){
                        res.status(500).json({error: err})
                        return;
                    }

                    var dados = {
                        url_imagem: url_imagem,
                        titulo: req.body.titulo
                    }
                    console.log('Dentro do fs, mostrar dados: ', dados);

                    // Aqui será feito a requisição ao banco de dados.
                    // main().collection('postagens').insertOne(dados);
                });
            });
        Assim, a estrutura acima, nos permite conseguir carregar a imagem ao uploads e, além disso, nos permite salvar tais informações no banco de dados, MongoDB, o que falta é só configurar tal banco de dados para possibilitar tal uso.
        Obs: pelo visto só aceita a imagem no formato .jpg.
        Realizar os estudos do MongoDB atualizado para verificar a forma como podemos implementar isso nesse projeto instagram_clone.
        Além disso, será necessário criar um identificador único da imagem, pois se fizermos novamente o upload da mesma imagem, no diretório uploads não mudará nada e no banco de dados, haverá dois dados com as mesmas imagens salvas.
        Para isso, iremos utilizar o identificador único, que é o tempo, para possibilitar que dois usuários publiquem as duas mesmas imagens.
        Assim, no server.js, fazemos a seguinte alteração no POST create
            // POST (create)
            app.post('/api', function(req, res){

                // res.setHeader("Access-Control-Allow-Origin", "http://localhost:80");
                res.setHeader("Access-Control-Allow-Origin", "*");

                // var dados = req.body;

                // console.log(dados);

                // console.log(req.files);

                // res.send(dados);

                var date = new Date();

                var time_stamp = date.getTime();

                var url_imagem = time_stamp + '_' + req.files.arquivo.originalFilename;

                var path_origem = req.files.arquivo.path;
                var path_destino = './uploads/' + url_imagem;

                fs.rename(path_origem, path_destino, function(err){
                    if(err){
                        res.status(500).json({error: err})
                        return;
                    }

                    var dados = {
                        url_imagem: url_imagem,
                        titulo: req.body.titulo
                    }
                    console.log('Dentro do fs, mostrar dados: ', dados);

                    // Aqui será feito a requisição ao banco de dados.
                    // main().collection('postagens').insertOne(dados);
                });
            });
        Agora, tentamos realizar novamente a inclusão.
        Podemos ver que, agora, estamos conseguindo fazer o upload da mesma imagem várias vezes e no diretório uploads tais imagens estão sendo várias vezes carregadas com o identificador único nelas.

    Aula 21 - Exibindo postagens na timeline:
        Agora que estamos conseguindo salvar as informações de publicações no banco de dados.
        Queremos agora publicar de fato na timeline.
        Para isso, vamos realizar as seguinte alterações no padrao.ejs que está no views do app do cliente)web_instagram_clone.
            <script>
                $(document).ready(function(){

                    function carrega_postagens(){
                        // criar xmlhttprequest
                        var xhr = new XMLHttpRequest();

                        xhr.open("GET", "http://localhost:8080/api");

                        xhr.onload = function() {
                            if(xhr.status == 200) {
                                // status acima é o mesmo que é devolvido quando testamos no Postman
                                alert('Tudo ok!');
                            }
                        }

                        xhr.send();
                    }

                    carrega_postagens();

                    $('#btn_incluir').click(function(){
                        $('#container_timeline').hide();
                        $('#container_form').show();
                    });

                    $('#btn-cancelar-publicacao').click(function(){
                        $('#container_timeline').show();
                        $('#container_form').hide();
                        return false;
                    });

                    $('#btn-publicar').click(function(){
                        // criar um formData
                        var formData = new FormData(); // chave=valor

                        var arquivo = document.getElementById("arquivo").files[0];
                        var titulo = document.getElementById("titulo").value;

                        formData.append("arquivo", arquivo);
                        formData.append("titulo", titulo);

                        // criar xmlhttprequest
                        var xhr = new XMLHttpRequest();

                        // verificar as mudanças de estado
                        xhr.onreadystatechange = function() {
                            if(xhr.readyState == 4) {
                                var resposta = xhr.responseText;
                                document.getElementById('mensagem').innerHTML = resposta;
                            }
                        }

                        // fazer o envio do nosso request
                        xhr.open("POST", "http://localhost:8080/api");
                        xhr.send(formData);
                    });

                });
            </script>
        No caso, quando rodarmos novamente o localhost/home, teremos o mesmo problema que tivemos quando estávamos tentando carregar uma imagem.
            XMLHttpRequest cannot load
        Vamos precisar configurar isso tbm no get pelo server.js.
            // GET (ready)
            app.get('/api', function(req, res){
                var dados = req.body;

                res.setHeader("Access-Control-Allow-Origin", "*");

                res.send(dados);
                // main().collection('postagens').find().toArray(function(err, results){
                //     if(err){
                //         res.json(err);
                //     } else {
                //         res.json(results);
                //     }
                // });
            });
        Visto que está funcionando acima, vamos realizar a seguinte implementação no script do padrao.ejs.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = xhr.responseText;
                        console.log(data);
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Para verificarmos o que está sendo retornado dessa msg.
        No caso, se estivermos conectado ao banco de dados, mongoDB, deveria estar filtrando os dados da coleção postagens.
        Por hora, como precisa-se realizar um estudos para verificarmos como fazemos tal requisição, no console log, está sendo retornado um objeto vazio.
        Para garantirmos que o dado, na varável data acima, está sendo feito em objeto, vamos realizar a seguinte implementação.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        console.log(data);
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Daí, se testarmos, visto que foi configurado a conexão com o banco de dados, estará funcionando.
        Assim, vamos poder iterar as postagens, pois visto que está retornando um objeto, podemos usar o for, para conseguirmos iterar.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                '</div>'
                            );
                        }
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Entretanto, ainda não será possível exibir as imagens, mesmo sendo carregadas.
        A resolução disso será visto na próxima aula.

    Aula 22 - Exibindo imagens:
        Para resolvermos o problema da imagem existem várias vias.
        Porém, uma alternativa para resolvermos isso, que não foge tanto do escopo do curso, é usando o código.
        No caso, iremos realizar a seguinte implementação no server.js, que é mais um get voltado para o outro diretório.
            app.get('/imagens/:imagem', function(req, res) {
                var img = req.params.imagem;

                fs.readyFile('./uploads/' + img, function(err, content){
                    if(err) {
                        res.status(400).json(err);
                        return;
                    }

                    res.writeHead(200, { 'content-type': 'image/jpg' });
                    res.end(content);
                })
            });
        No caso, com a implementação acima, conseguimos exibir as imagens carregadas.

    Aula 23 - Incluindo comentários em postagens - parte 1:
        Visto que agora cada postagem está exibindo o título e a imagem, vamos iniciar uma forma de conseguirmos colocar comentários para cada postagem.
        Por hora, só vamos preparar o ambiente para possibilitar tais implementações mais sofisticadas para a próxima aula.
        No caso, no padrao.ejs, vamos realizar o seguinte em script onde criamos a função carrega_postagens.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Feito acima, em cada postagem será configurado uma parte para comentários.
        Assim, o ambiente está pronto para realizar as implementações das lógicas.

    Aula 24 - Incluindo comentários em postagens - parte 2:
        Vamos agora implementar as lógicas ao botão comentário, visto que já foi criado o ambiente para isso.
        No caso, em padrao.ejs, no script, vamos usar o jquery para realizar tais implementações.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            alert('Teste!');
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Note que, na implementação, só foi feito para testar se realmente o botão Comentar está funcionando via jquery.
        Visto que o alert está funcionando, então vamos precisar considerar o conteúdo na qual está sendo colocado dentro do comentário.
        Para isso, na mesma função carrega_contagens, na div button, vamos colocar o value e puxar esse value dentro do jquery em que colocamos o alert.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            alert(value);
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Agora, novamente, podemos testar se agora, quando clicado no botão Comentar, está sendo devolvido o id da postagem feita.
        Visto que está funcionando isso, então na div input vamos definir um atributo id e nela passar o valor do id da postagem.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            alert(value);
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Com o formato acima, cada coisa que colcarmos no input, como estamos linkando com o id único da postagem, vamos ter a referência, pelo value que foi definido no button, para acessar o conteúdo que foi colocado dentro do input.
        No caso, no evento click que foi definido via jquery para btn_postagem, vamos realizar a seguinte implementação.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            alert(id_input_comentario);
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Visto que agora, estamos conseguindo referenciar ao id do input, então vamos recuperar o comentário que é colocado dentro de input.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            alert(comentario);
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Agora, podemos testar se colocando algum comentário, está sendo trago de fato o comentario que foi colocado pelo alert acima.
        Visto que está sendo feito de forma bem sucedida, então só falta enviarmos essa informação no nosso api.

    Aula 25 - Incluindo comentários em postagens - parte 3:
        No caso, como estamos conseguindo capturar agora a msg que é inserido na aba de comentários, via jquery, só falta agora enviarmos essa informação para api, especificamente para o put, no server.js, para atualizarmos as informações da postagem no banco de dados.
        Logo, vamos implementar isso pouco a pouco do que está escrito na postagem.
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                res.send('rota para atualização');
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $set : { titulo: req.body.titulo }},
                //     {},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Vamos testar se a rota está tudo ok.
        Para isso, vamos utilizar o Postman com o método PUT e nela colocar algum id, localhot:8080/api/(algum id).
        Visto que está retornando o send como configuramos acima, então vamos agora implementar, pouco a pouco, as lógicas necessárias para isso.
        Então, em padrao.ejs, na função carrega_postagens, no envento click que definimos, vamos realizar o seguinte.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.send();
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Com a configuração acima, podemos testar se o evento click que definimos para btn_postagem está conseguindo requisitar a api que definimos.
        Bom, como ocorreu da mesma forma anteriormente, provalmente, não, pois ainda precisaria resolver o problema do XMLHttpRquest cannot load.
        Bastaríamos fazer o mesmo, como foi feito para os outros métodos, para resolvermos esse problema.
        No caso, no método put que definimos em server.js, colocamos
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                res.setHeader("Access-Control-Allow-Origin", "*");
                res.send('rota para atualização');
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $set : { titulo: req.body.titulo }},
                //     {},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Mas ainda assim ainda não é o suficiente, pois agora temos o problema novo, diferente do Access control, como havia tido antes.
        O problema seria a de preflight, que é o que precisamos resolver e iremos fazer isso na próxima aula.

    Aula 26 - Preflight Request:
        Leitura de conceito:
            https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request#:~:text=A%20CORS%20preflight%20request%20is,Headers%20%2C%20and%20the%20Origin%20header.
            https://docs.sensedia.com/pt/faqs/Latest/apis/preflight.html#:~:text=Comportamento-,Requisi%C3%A7%C3%A3o%20preflight,requisi%C3%A7%C3%A3o%20HTTP%20efetiva%20%C3%A9%20realizada.
            https://developer.mozilla.org/pt-BR/docs/Glossary/Preflight_request
            https://learn.microsoft.com/pt-br/rest/api/storageservices/preflight-queue-request

    Aula 27 - Incluindo comentários em postagens - parte 4:
        Vamos resolver esse problema de preflight.
        Logo, no arquivo server.js, vamos definir um novo app.use da seguinte forma
            app.use(function(req, res, next){

                // isso é um middleware
                res.setHeader("Access-Control-Allow-Origin", "*");
                res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");
                // O motivo de ser o content-type seria e precisamos informar que o tipo de conteúdo que está sendo enviado é um JSON.
                res.setHeader("Access-Control-Allow-Headers", "content-type");
                res.setHeader("Access-Control-Allow-Credentials", true);

                next();
            });
        Visto que confguramos esse middleware, podemos retirar todos os setHeaders que colocamos uma por uma em cada método.
        Em seguida, em padrao.ejs, no evento click para btn_postagem definida e dentro de xhr.send(), podemos enviar o conteúdo que está sendo colocado no input.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.setRequestHeader('Content-Type', 'application/json');

                            xhr.onload = function(){
                                alert(xhr.responseText);
                            }

                            xhr.send(JSON.stringify({comentario: comentario}));
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        No caso, isso fará com que seja enviado uma string para o método PUT
        Podemos testar isso inserindo algum comentário e se tudo ocorrer certo, irá aparecer o alert onde irá exibir o send, "rota para atualização", que está configurado no método put do server.js.
        Vamos testar se no método put está de fato retornando o id correto.
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                // res.setHeader("Access-Control-Allow-Origin", "*");
                // res.send('rota para atualização');
                res.send(req.params.id);
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $set : { titulo: req.body.titulo }},
                //     {},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Basta, novamente, inserir algum comentário e clicado, verificar o que irá ser exibido pelo alert.
        Agora, vamos verificar se está sendo enviado, de fato, o comentário.
        No server.js, colocamos.
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                // res.setHeader("Access-Control-Allow-Origin", "*");
                // res.send('rota para atualização');
                // res.send(req.params.id);
                res.send(req.body.comentario);
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $set : { titulo: req.body.titulo }},
                //     {},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Novamente, inserimos algum comentário e clicamos no evento para verficarmos se está sendo de fato enviado a msg.
        Visto que foi enviado, agora, estamos prontos para atualizar isso no banco de dados da postagem em que o comentário foi inserido.

    Aula 28 - Incluindo comentários em postagens - parte 5:
        Agora, vamos, de fato, atualizar o conteúdo.
        Para isso, no método put que estamos utilizando, antes, usávamos $set, mas agora iremos usar o $push para conseguirmos incluir um novo conteúdo dentro do objeto json que estão salvos os conteúdos da postagem.
            // PUT by ID (update)
            app.put('/api/:id', function(req, res){
                // res.setHeader("Access-Control-Allow-Origin", "*");
                // res.send('rota para atualização');
                // res.send(req.params.id);
                res.send(req.body.comentario);
                // var dados = req.body;

                // res.send(dados);
                // Lugar para requisitar o banco de dados, MongoDB.
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $push : {
                //         comentarios: {
                //             id_ comentario: new objectId(),
                //             comentario: req.body.comentario
                //             }
                //         }
                //     },
                //     {},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Feito isso, vamos poder testar, visto que conseguimos configurar a conexão com o MongoDB.
        Para verificarmos se estamos conseguindo pegar exatamente o que está sendo retornado pelo banco de dados se foi ou não bem sucedido a operação, podemos implementar no padrao.ejs, em script com o evento click btn_postagem definido, o seguinte.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.setRequestHeader('Content-Type', 'application/json');
                            
                            xhr.onload = function(){
                                // alert(xhr.responseText);
                                if(xhr.status === 200) {
                                    window.location.href = '/home';
                                }
                            }

                            xhr.send(JSON.stringify({comentario: comentario}));
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        No caso, isso nos permitirá verificar se, de fato, a inclusão do comentário no banco de dados foi bem sucedida ou não via a página padrao.ejs.

    Aula 29 - Exibindo comentários:
        Agora que estamos conseguindo incluir os comentários no banco de dados falta, agora, exibir esses comentários nas respectivas postagens.
        No caso, no arquivo padrao.js, no container_timerline, nela que iremos realizar a implementaçãoa necessária para conseguirmos exibir tais comentários.
        Então realizamos o seguinte.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentarios" id="comentarios_"' + data[i]._id + '></div>' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );

                            if(data[i].comentarios != undefined){
                                var comentarios = data[i].comentarios;

                                for(j = 0; j < comentarios.lenght; j++){
                                    $('#comentarios_'+data[i]._id).append(
                                        '<div class="txt_comentario">' +
                                            comentarios[j].comentario +
                                        '</div>'
                                    );
                                }
                            }
                        }

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.setRequestHeader('Content-Type', 'application/json');
                            
                            xhr.onload = function(){
                                // alert(xhr.responseText);
                                if(xhr.status === 200) {
                                    window.location.href = '/home';
                                }
                            }

                            xhr.send(JSON.stringify({comentario: comentario}));
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Isso já possibilita a exibição dos comentários para os respectivos posts.
        Além disso, ao inserirmos um novo comentário, será possível ver que o mesmo já é exibido em seguida.

    Aula 30 - Removendo comentários - parte 1:
        Vamos agora aprender a remover os comentários.
        No caso, primeiro, vamos criar os ambientes necessários para isso.
        Iremos usar o método DELETE.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentarios" id="comentarios_"' + data[i]._id + '></div>' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );

                            if(data[i].comentarios != undefined){
                                var comentarios = data[i].comentarios;

                                for(j = 0; j < comentarios.lenght; j++){
                                    $('#comentarios_'+data[i]._id).append(
                                        '<div class="txt_comentario">' +
                                            '<button type="button" value="' + comentarios[j].id_comentario + '" class="btn btn_default btn_remover_postagem">X</button>' +
                                            comentarios[j].comentario +
                                        '</div>'
                                    );
                                }
                            }
                        }

                        $('.btn_remover_postagem').click(function(){
                            var id_comentario = this.value;
                            alert(id_comentario);
                        });

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.setRequestHeader('Content-Type', 'application/json');
                            
                            xhr.onload = function(){
                                // alert(xhr.responseText);
                                if(xhr.status === 200) {
                                    window.location.href = '/home';
                                }
                            }

                            xhr.send(JSON.stringify({comentario: comentario}));
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Com a implementação de um novo evento de click para remover comentário feito acima e visto que ela está nos retornando o id_comentario certo, agora em server.js no método delete vamos ter que receber esse valor para conseguirmos deletá-las.
            // DELETE by ID (remove)
            app.delete('/api/:id', function(req, res){
                res.send(req.params.id);
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').deleteOne({ _id : objectId(req.params.id) }, function(err, records) {
                //     if(err) {
                //         res.json(err);
                //     } else {
                //         res.json(records);
                //     }

                //     // colocar o comando que fecha a conexão com o banco de dados.
                // });
            });
        Vamos, agora, ir no padrao.ejs e lá na função carrega_postagens no envento de click para remover comentário precisamos disparar esse método que está definido no server.js.
            function carrega_postagens(){
                // criar xmlhttprequest
                var xhr = new XMLHttpRequest();

                xhr.open("GET", "http://localhost:8080/api");

                xhr.onload = function() {
                    if(xhr.status === 200) {
                        // status acima é o mesmo que é devolvido quando testamos no Postman
                        // alert('Tudo ok!');
                        var data = $.parseJSON(xhr.responseText);
                        // console.log(data);

                        for(i = 0; data.length; i++) {
                            // alert(data[i])
                            $('#container_timeline').append(
                                '<div class="publicacao">'+
                                    '<span class="titulo">' + 
                                        data[i].titulo +
                                    '</span>' +
                                    '<img src="http://localhost:8080/uploads/' + data[i].url_imagem + '" />' +
                                    '<div class="comentarios" id="comentarios_"' + data[i]._id + '></div>' +
                                    '<div class="comentar">' +
                                        '<input type="text" class="form-control input_comentario" id="postagem_' + data[i]._id+ '" placeholder="Adicione um comentário...">' +
                                        '<button class="btn btn-default btn_postagem" value="'+ data[i]._id +'" type="button">Comentar</button>' +
                                    '</div>' +
                                '</div>'
                            );

                            if(data[i].comentarios != undefined){
                                var comentarios = data[i].comentarios;

                                for(j = 0; j < comentarios.lenght; j++){
                                    $('#comentarios_'+data[i]._id).append(
                                        '<div class="txt_comentario">' +
                                            '<button type="button" value="' + comentarios[j].id_comentario + '" class="btn btn_default btn_remover_postagem">X</button>' +
                                            comentarios[j].comentario +
                                        '</div>'
                                    );
                                }
                            }
                        }

                        $('.btn_remover_postagem').click(function(){
                            var id_comentario = this.value;
                            // alert(id_comentario);

                            var xhr = new XMLHttpRequest();
                            xhr.open('DELETE', 'http://localhost:8080/api/' + id_comentario);
                            
                            xhr.onload = function(){
                                // alert(xhr.responseText);
                                if(xhr.status === 200) {
                                    alert(xhr.responseText);
                                }
                            }
                            xhr.send();
                        });

                        $('.btn_postagem').click(function(){
                            // alert('Teste!');
                            var id = this.value;
                            // alert(value);
                            var id_input_comentario = 'postagem_' + id;
                            // alert(id_input_comentario);
                            var comentario = $('#' + id_input_comentario).val();
                            // alert(comentario);
                            var xhr = new XMLHttpRequest();
                            xhr.open('PUT', 'http://localhost:8080/api/' + id);
                            xhr.setRequestHeader('Content-Type', 'application/json');
                            
                            xhr.onload = function(){
                                // alert(xhr.responseText);
                                if(xhr.status === 200) {
                                    window.location.href = '/home';
                                }
                            }

                            xhr.send(JSON.stringify({comentario: comentario}));
                        });
                    }
                }

                xhr.send();
            }

            carrega_postagens();
        Depois que fizermos isso, vamos testar clicando no X em algum comentário.
        Se aparecer um alert com o id do comentário na qual está sendo enviado pelo método delete que está sendo configurado no server.js, então está tudo ocorrendo certo.
        Agora, basta acionar o banco de dados para removermos tal comentário via id.

    Aula 31 - Removendo comentários - parte 2:
        Vamos agora deletar os comentários.
        No caso, para isso, vamos usar, dentro do método delete, o comando update.
        No caso, no server.js do método delete definimos.
            // DELETE by ID (remove)
            app.delete('/api/:id', function(req, res){
                res.send(req.params.id);
                // var dados = req.body;

                // res.send(dados);
                // main().collection('postagens').deleteOne({ _id : objectId(req.params.id) }, function(err, records) {
                //     if(err) {
                //         res.json(err);
                //     } else {
                //         res.json(records);
                //     }

                //     // colocar o comando que fecha a conexão com o banco de dados.
                // });

                // Lugar para requisitar o banco de dados, MongoDB.
                // main().collection('postagens').update(
                //     { _id : objectId(req.params.id) },
                //     { $pull : {
                //         comentarios: {
                //             id_ comentario: objectId(req.params.id)
                //             }
                //         }
                //     },
                //     {multi: true},
                //     function(err, records) {
                //         if(err) {
                //             res.json(err);
                //         } else {
                //             res.json(records);
                //         }

                //         // colocar o comando que fecha a conexão com o banco de dados.
                //     }
                // );
            });
        Agora, vamos conseguir remover os comentários.

    Aula 32 - Download dos arquivos do projeto:
        Download dos arquivos do projeto
        Utilize o link disponibilizado como recurso dessa aula para fazer o download dos arquivos do projeto API RESTFull e Instagram Clone WEB no estado em que se encontram na aula anterior.

        Bons estudos ;)

Seção 21 - Complementos do curso:
    Aula 1 - Download servidor NodeJS pré-configurado:
        Download servidor NodeJS pré-configurado
        Utilize o link disponibilizado como recurso dessa aula para fazer o download de uma aplicação NodeJS pré-configurada com o Express, o EJS, o Consign, o Body-parser e o Express-validator.

        Bons estudos ;)

    Aula 2 - Trabalhando com o MongoDB 3.6 no projeto final MMORPG GOT:
        Trabalhando com o MongoDB 3.6 no projeto final MMORPG GOT
        Confira no PDF disponibilizado nessa aula algumas dicas para trabalhar com o MongoDB na versão 3.6 em conjunto com o NodeJS aplicado ao projeto final MMORPG Got.



        Bons estudos ;)

Seção 22 - Bônus:
    Aula 1 - Não deixe de conferir ;):
        Não deixe de conferir ;)
        Olá,



        E ai, está curtindo a curso? Então que tal conhecer um pouco mais do meu trabalho?

        Acesse www.jorgesantana.net.br e confira.



        Forte abraço e sucesso!
